<context>
# Overview

Puffin (Personal Unified Finance Framework & Investment Navigator) is a locally-hosted personal budgeting application for tracking expenses, categorising transactions, and monitoring spending against budgets. It solves the problem of expense tracking without relying on cloud-based services or subscription fees, while enabling multi-device access through Google Drive database synchronisation.

The application is designed for individuals or households who want full control over their financial data, prefer local-first software, and need to access their budget from multiple computers. Unlike YNAB or GoodBudget, Puffin keeps all data local with optional manual sync to a shared Google Drive location.

**Target User:** Privacy-conscious individuals comfortable with self-hosted applications who want detailed expense tracking with budget comparison capabilities.

**Core Value Proposition:**
- Full data ownership with local SQLite database
- No subscription fees or cloud lock-in
- Multi-device access via Google Drive sync
- Flexible categorisation with auto-categorisation rules
- Clear visibility of spending as percentage of income
- Standalone desktop application — no Node.js installation required

# Core Features

## 1. Transaction Import & Entry

**What it does:** Allows users to import transactions from CSV files or manually enter them.

**Why it's important:** The foundation of expense tracking — getting transaction data into the system efficiently and accurately.

**How it works:**
- Import simple or extended CSV files via file upload
- Preview imported data in a table format with dropdown column mappers (date, description, amount)
- Option to remove unwanted rows before import
- Duplicate detection flags matching transactions (same date, amount, description) with option to skip
- Manual transaction entry form for accounts without export functionality
- Fields: date, description, amount, optional notes
- All transactions treated as single pool regardless of source account

## 2. Transaction Categorisation

**What it does:** Enables users to assign categories to transactions, with support for auto-categorisation rules.

**Why it's important:** Categorisation transforms raw transaction data into meaningful spending insights.

**How it works:**
- Two-tier category system: upper categories (renameable, default: Expense, Saving, Bill, Debt, Income, Transfer) and user-defined sub-categories
- Uncategorised inbox showing all unassigned transactions sorted by date (newest first)
- Auto-categorisation rules using "contains exact text" matching with drag-to-reorder priority
- Rules applied silently on import; categories always editable
- Transaction splitting: divide one transaction into up to 3 parts by amount, creating separate linked transactions with reversible history
- Transfer category ignored in reporting calculations

## 3. Monthly Budget View

**What it does:** Displays a month's transactions organised by category with actual vs budget comparison.

**Why it's important:** The primary view for understanding monthly spending and staying within budget.

**How it works:**
- Upper categories as section headers, sub-categories listed beneath
- Two columns per sub-category: Actual (calculated) and Budget (user-entered)
- Actual highlighted red when exceeding budget
- Budget entry options: fresh entry, carry over from last month, or reference watermark showing last month/average of 3 or 6 months
- Sub-categories with no budget show 0
- All month's transactions listed below category summary, editable for re-categorisation
- Click-through from sub-category totals to filtered transaction list

## 4. Dashboard & Analytics

**What it does:** Provides overview of financial health with key metrics and visualisations.

**Why it's important:** Enables quick assessment of spending patterns and trends without navigating multiple views.

**How it works:**
- Default landing page on app open
- Percentage-of-income breakdown showing how income divides across sub-categories (actuals only)
- Line graph: monthly spending trends over time
- Pie chart: income allocation across sub-categories
- Line graphs: trends for each upper category
- Month-over-month and year-over-year tables with selectable periods (3, 6, or 12 months)
- Drill-down to monthly or yearly detail views

## 5. Auto-Categorisation Rules Management

**What it does:** Allows users to create, edit, and prioritise rules that automatically categorise matching transactions.

**Why it's important:** Reduces manual categorisation effort for recurring transactions.

**How it works:**
- Settings page listing all rules
- Each rule: match text (exact contains) → assigns sub-category
- Drag-to-reorder for priority (first match wins)
- Add, edit, delete rules
- Rules cannot auto-assign splits

## 6. Google Drive Sync

**What it does:** Synchronises the local database to a shared Google Drive location for multi-device access.

**Why it's important:** Enables access from multiple computers without complex server infrastructure.

**How it works:**
- Manual sync trigger (not automatic background sync)
- On app open: prompt to pull latest from Google Drive
- On app close: block closing until sync completed
- "Last synced" banner displayed at all times
- Local backup created before each sync
- Conflict resolution: last-write-wins
- Supports multiple users with their own Google accounts accessing the same shared folder location (not simultaneously)
- User pastes Google Drive folder URL; app validates access before saving
- Sync configuration is optional — app works fully offline until configured

## 7. Undo System

**What it does:** Allows reversal of recent actions including deletions.

**Why it's important:** Provides safety net for mistakes, especially for destructive actions.

**How it works:**
- Soft-delete for transactions (recoverable)
- Undo last action button (Ctrl+Z pattern)
- Split transactions reversible to original single transaction

## 8. Desktop Application

**What it does:** Packages the application as a standalone Windows executable.

**Why it's important:** Enables distribution without requiring users to install Node.js or run command-line tools.

**How it works:**
- Single portable .exe file — no installer required
- Double-click to launch; no dependencies for end users
- Distributed via GitHub Releases for version management and easy downloads
- Auto-update notifications prompt user to download new versions from GitHub Releases
- All data stored in standard Windows user data location (%APPDATA%)

## 9. Net Worth Tracking

**What it does:** Enables users to record periodic snapshots of their total assets and liabilities to track net worth over time with visual projections.

**Why it's important:** Provides a holistic view of financial health beyond monthly budgeting, helping users track wealth accumulation and progress toward financial goals.

**How it works:**
- Standalone page separate from transaction-based budgeting
- "Record Net Worth" button opens a form with predefined asset and liability fields
- **Asset fields (customizable labels):**
  - Home (at purchase price), Car (current value)
  - Stocks 1, Stocks 2, Superannuation 1, Superannuation 2
  - Cash, Offset account
  - Asset 1, Asset 2, Asset 3, Asset 4 (generic slots)
- **Liability fields (customizable labels):**
  - Mortgage, Credit Card Debt, Car Loan
  - Debt 1, Debt 2, Debt 3, Debt 4 (generic slots)
- Each field has an editable label (persisted per entry) and value input
- Calculates: Total Assets, Total Liabilities, Net Worth (assets - liabilities)
- Entries displayed in a table with date, totals, and edit/delete actions
- Delete requires confirmation dialog with prominent warning
- Line chart showing net worth over time (Y-axis: net worth, X-axis: date)
- Dashed projection line extending 5 years into future using linear regression
- Data stored in SQLite database and included in Google Drive sync

# User Experience

## User Persona

**Primary User:** Individual or household member managing personal/family finances. Technically comfortable (can run local web applications), values data privacy and ownership, accesses budget from home desktop and laptop. Wants clear visibility of where money goes without subscription fees.

## Key User Flows

### First-Time Setup
1. Launch application (double-click .exe or run via npm in development)
2. Optionally configure Google Drive sync location (can skip for offline-only use)
3. Rename upper categories if desired
4. Create initial sub-categories
5. Import first CSV file
6. Map columns and confirm import
7. Categorise transactions in inbox

### Regular Usage (Weekly/Fortnightly)
1. Open app → sync from Google Drive (if configured)
2. Import new transactions from bank CSV
3. Review duplicate warnings, skip as needed
4. Process uncategorised inbox
5. Set/adjust monthly budgets
6. Review dashboard for spending insights
7. Sync to Google Drive before closing (if configured)

### Month-End Review
1. Open monthly view for completed month
2. Review actual vs budget per category
3. Adjust next month's budgets based on actuals
4. Check dashboard trends
5. Create new sub-categories if spending patterns changed

## UI/UX Considerations

- Clean, minimal interface prioritising data clarity
- Consistent navigation: Dashboard, Monthly View, Inbox, Net Worth, Settings
- Import wizard: step-by-step with preview table
- Red highlighting for over-budget items (clear visual alert)
- Watermarks for budget history (subtle, non-intrusive)
- Sync status always visible (when configured)
- Blocking sync prompt on close (modal, cannot dismiss without syncing) — only when sync configured
- Responsive design for different screen sizes

</context>
<PRD>
# Technical Architecture

## System Components

### Frontend
- **Framework:** Next.js 14+ with TypeScript
- **Styling:** Tailwind CSS
- **Component Library:** shadcn/ui (built on Radix primitives)
- **Charts:** Recharts
- **State Management:** React Context (upgrade to Zustand if complexity warrants)

### Backend
- **Runtime:** Node.js via Next.js API routes (development mode)
- **Database:** SQLite (single file, portable)
- **Database Library:** better-sqlite3 for development; tauri-plugin-sql for packaged app
- **Database Abstraction:** Thin abstraction layer (db.ts) to enable seamless swap between libraries
- **Authentication:** Local password protection (hashed, stored in database)

### Desktop Runtime
- **Framework:** Tauri 2.x
- **Webview:** Windows WebView2 (Edge-based, pre-installed on Windows 10/11)
- **Build output:** Portable .exe, no installer

### Storage & Sync
- **Local Storage:** SQLite database file in application directory
- **Remote Storage:** Google Drive API for database file sync
- **Backup:** Local timestamped copies before sync
- **Config Storage:** Local JSON file for settings (separate from database)

### Development & Testing
- **Package Manager:** npm
- **Testing Framework:** Vitest
- **Linting:** ESLint with Next.js config
- **Formatting:** Prettier

**Test Failure Policy:** When Vitest tests fail, do NOT automatically fix the issue or modify the test. Report failing test(s) and error message to the user, explain what the test is checking and why it might be failing, then wait for user input on how to proceed.

## Data Models

### LocalUser
```
id: INTEGER PRIMARY KEY
password_hash: String (bcrypt)
created_at: Timestamp
updated_at: Timestamp
```
*Single row table for local authentication*

### Transaction
```
id: UUID
date: Date
description: String
amount: Decimal (negative for expenses, positive for income)
notes: String (nullable)
sub_category_id: FK (nullable - null means uncategorised)
is_split: Boolean
parent_transaction_id: UUID (nullable - for split children)
is_deleted: Boolean (soft delete)
created_at: Timestamp
updated_at: Timestamp
```

### UpperCategory
```
id: UUID
name: String
display_order: Integer
is_transfer: Boolean (excluded from reporting)
created_at: Timestamp
```

### SubCategory
```
id: UUID
name: String
upper_category_id: FK
created_at: Timestamp
```

### Budget
```
id: UUID
sub_category_id: FK
month: Date (first of month)
amount: Decimal
created_at: Timestamp
updated_at: Timestamp
```

### AutoCategoryRule
```
id: UUID
match_text: String (exact contains match)
sub_category_id: FK
priority: Integer (lower = higher priority)
created_at: Timestamp
```

### SyncLog
```
id: UUID
sync_type: Enum (push, pull)
timestamp: Timestamp
status: Enum (success, failed)
backup_path: String (nullable)
```

### NetWorthEntry
```
id: UUID
recorded_at: Date (snapshot date)
assets_data: JSON (field labels and values)
liabilities_data: JSON (field labels and values)
total_assets: Decimal (calculated sum)
total_liabilities: Decimal (calculated sum)
net_worth: Decimal (total_assets - total_liabilities)
notes: String (nullable)
created_at: Timestamp
```

**JSON structure for assets_data/liabilities_data:**
```json
{
  "home": { "label": "Home (Purchase)", "value": 650000 },
  "car": { "label": "Tesla Model 3", "value": 45000 },
  "stocks_1": { "label": "Vanguard ETF", "value": 30000 },
  "stocks_2": { "label": "Stocks 2", "value": 0 },
  "super_1": { "label": "AustralianSuper", "value": 120000 },
  "super_2": { "label": "Superannuation 2", "value": 0 },
  "cash": { "label": "Savings Account", "value": 15000 },
  "offset": { "label": "Offset Account", "value": 25000 },
  "asset_1": { "label": "Asset 1", "value": 0 },
  "asset_2": { "label": "Asset 2", "value": 0 },
  "asset_3": { "label": "Asset 3", "value": 0 },
  "asset_4": { "label": "Asset 4", "value": 0 }
}
```
*Liabilities follow same structure with keys: mortgage, credit_card, car_loan, debt_1-4*

## APIs and Integrations

### Internal API Routes (Next.js)
- `POST /api/transactions/import` - Process CSV upload
- `GET/POST/PATCH/DELETE /api/transactions` - CRUD operations
- `POST /api/transactions/:id/split` - Split transaction
- `POST /api/transactions/:id/unsplit` - Reverse split
- `GET/POST/PATCH/DELETE /api/categories` - Category management
- `GET/POST/PATCH/DELETE /api/rules` - Auto-categorisation rules
- `GET/POST /api/budgets` - Budget management
- `GET/POST /api/net-worth` - List and create net worth entries
- `GET/PUT/DELETE /api/net-worth/:id` - Read, update, delete net worth entry
- `POST /api/sync/push` - Push to Google Drive
- `POST /api/sync/pull` - Pull from Google Drive
- `GET /api/analytics/*` - Dashboard data endpoints

### External Integrations
- **Google Drive API:** OAuth2 authentication, file upload/download for database sync
- **No other external dependencies**

## Infrastructure Requirements

- Node.js 18+ runtime (development only)
- Local filesystem access for SQLite and backups
- Google account with Drive API access configured (optional)
- Browser for UI access (development) or Tauri webview (packaged)
- Default port: 3000 (development mode)
- Works entirely offline; sync only when manually triggered

# Development Roadmap

## Phase 1: Foundation & Data Layer

**Scope:** Core database structure, basic transaction management, and minimal UI shell.

### 1.1 Project Setup
- Initialise Next.js 14+ project with TypeScript and App Router
- Configure Tailwind CSS and shadcn/ui
- Set up SQLite with better-sqlite3
- Create database schema and initialisation scripts
- Configure Vitest for testing
- Establish project structure (app/, components/, lib/, api/)

### 1.2 Database Abstraction Layer
- Create `lib/db.ts` with functions for all database operations
- Abstract away direct better-sqlite3 calls
- Design interface to support future swap to tauri-plugin-sql
- Export functions like `getTransactions()`, `insertTransaction()`, `runQuery()`, etc.

### 1.3 Local Authentication
- LocalUser table with bcrypt password hash
- Password setup flow on first launch
- Login page with password entry
- Session management (HTTP-only cookie or similar)
- Protected route middleware

### 1.4 Database Models
- Implement all data models (LocalUser, Transaction, UpperCategory, SubCategory, Budget, AutoCategoryRule, SyncLog)
- Seed default upper categories (Expense, Saving, Bill, Debt, Income, Transfer)
- Create database utility functions (connection, backup, restore)

### 1.5 Basic API Routes
- Transaction CRUD endpoints
- Category CRUD endpoints
- Basic error handling and validation

### 1.6 Minimal UI Shell
- Layout component with navigation (Dashboard, Monthly, Inbox, Settings placeholders)
- Basic routing structure
- Placeholder pages for each main section

## Phase 2: Transaction Import & Entry

**Scope:** Get transactions into the system via CSV import and manual entry.

### 2.1 CSV Parser
- Parse simple CSV format (comma-separated, standard encoding)
- Parse extended CSV format (handle additional columns gracefully)
- Validate required fields present
- Handle date format variations (DD/MM/YYYY, YYYY-MM-DD, etc.)

### 2.2 Import UI
- File upload component
- Preview table showing parsed data
- Dropdown column mapper for each column (Date, Description, Amount, Ignore)
- Mutually exclusive selection (selecting Date removes it from other dropdowns)
- Row removal checkboxes
- Import confirmation button

### 2.3 Duplicate Detection
- Algorithm to identify potential duplicates (exact match: date + amount + description)
- UI to flag duplicates during import preview
- Skip/include toggle for each flagged duplicate

### 2.4 Manual Transaction Entry
- Form: date picker, description input, amount input, optional notes
- Validation (required fields, valid amount)
- Add to transaction list

### 2.5 Transaction List View
- Basic table of all transactions
- Sortable by date
- Display: date, description, amount, category (or "Uncategorised")

## Phase 3: Categorisation System

**Scope:** Two-tier categories, manual categorisation, and uncategorised inbox.

### 3.1 Category Management
- Upper category rename functionality
- Sub-category CRUD (create, rename, delete)
- Assign sub-categories to upper categories
- Settings page UI for category management

### 3.2 Uncategorised Inbox
- Filter transactions where sub_category_id is null
- Display as list sorted by date (newest first)
- Category assignment dropdown per transaction
- Count badge in navigation

### 3.3 Transaction Categorisation UI
- Dropdown to select sub-category (grouped by upper category)
- Inline editing in transaction lists
- Visual update on categorisation

### 3.4 Transaction Splitting
- Split button on transaction row
- Modal: specify 2-3 amounts that sum to original
- Assign category to each split portion
- Create child transactions linked to parent
- Mark parent as is_split=true
- Unsplit action: delete children, restore parent, clear is_split flag

## Phase 4: Auto-Categorisation Rules

**Scope:** Rule creation, management, and automatic application.

### 4.1 Rule Data Layer
- Rule CRUD API endpoints
- "Contains exact text" matching function
- Priority ordering logic

### 4.2 Rules Management UI (Settings)
- List all rules with match text, target category, priority
- Add new rule form
- Edit existing rule
- Delete rule with confirmation
- Drag-and-drop reordering for priority

### 4.3 Rule Application
- On transaction import: apply rules to uncategorised transactions
- Process in priority order, first match wins
- Rules applied silently (no confirmation needed)

## Phase 5: Monthly Budget View

**Scope:** Month view with category breakdown and budget comparison.

### 5.1 Monthly Data Aggregation
- API to aggregate transactions by sub-category for given month
- Calculate totals per sub-category and upper category
- Fetch budget amounts for month

### 5.2 Monthly View UI
- Month selector (previous/next navigation)
- Upper category sections with sub-categories listed beneath
- Two columns: Actual (calculated), Budget (editable input)
- Red highlighting when Actual > Budget
- Sub-category totals sum to upper category totals

### 5.3 Budget Entry
- Inline editable budget amounts
- "Carry over from last month" button
- Watermark showing last month's budget
- Option to show 3-month or 6-month average as watermark
- Save on blur or explicit save button

### 5.4 Transaction List in Monthly View
- All transactions for selected month listed below category summary
- Editable category per transaction
- Click sub-category total to filter transaction list to that category

## Phase 6: Dashboard & Analytics

**Scope:** Overview dashboard with charts and trend analysis.

### 6.1 Analytics API
- Percentage of income calculation (per sub-category)
- Monthly spending totals over time
- Upper category trends over time
- Month-over-month data (3, 6, 12 month views)
- Year-over-year comparison

### 6.2 Dashboard Layout
- Summary cards (total income, total expenses, net this month)
- Percentage-of-income breakdown panel
- Chart containers

### 6.3 Charts Implementation
- Line chart: monthly spending trends
- Pie chart: income allocation by sub-category
- Line charts: per upper category trends
- Period selector for trend charts

### 6.4 Tabular Reports
- Month-over-month table by upper category
- Year-over-year table
- Period selector (3, 6, 12 months)

## Phase 7: Google Drive Sync

**Scope:** Manual sync to/from Google Drive with conflict handling and user-configurable folder location.

### 7.1 Google Drive API Integration
- OAuth2 setup and token management
- File upload function (push database)
- File download function (pull database)
- Check file modified timestamp

### 7.2 Sync Logic
- Local backup before any sync operation
- Push: upload local database to Drive
- Pull: download Drive database, replace local
- Last-write-wins conflict resolution
- Update SyncLog on each operation

### 7.3 Sync UI
- "Last synced" banner (always visible when sync configured)
- Manual sync buttons (push/pull)
- Sync status indicator (syncing, success, error)
- Banner hidden when sync not configured

### 7.4 Sync Prompts
- On app open: modal prompting to pull from Drive (only if sync configured)
- On app close: blocking modal requiring sync before close (only if sync configured)
- Cannot dismiss close modal without completing sync or explicitly skipping

### 7.5 Settings: Google Drive Configuration

**Folder Location Input**
- User pastes Google Drive folder URL (e.g., `https://drive.google.com/drive/folders/1aBcDeFgHiJkLmNoPqRsTuVwXyZ`)
- App extracts folder ID from URL automatically
- Validation on save:
  - Authenticate with user's Google account (OAuth2 flow)
  - Attempt to list folder contents via Drive API
  - Attempt to create/delete a test file (`.puffin-validation-test`) to confirm write access
  - Display success message with folder name confirmation
  - On failure: clear error message ("Folder not found", "No access to this folder", "Read-only access — write permission required")
- Store folder ID (not full URL) in local config file

**Multi-User Shared Folder Setup**
- Each user authenticates with their own Google account
- Each user pastes the same shared folder URL
- Folder must be shared with both Google accounts (standard Drive sharing)
- App validates each user's access independently
- No awareness of other users — each instance treats it as single-user access to a shared location

**Offline-Only Mode**
- Google Drive configuration is optional
- App fully functional without sync configured
- Settings page shows "Not configured" state with setup prompt
- Sync-related UI (banner, prompts) hidden until configured
- User can configure sync at any time

**Configuration Storage**
- Folder ID stored in local config file (not in SQLite database)
- OAuth refresh token stored securely (OS keychain via Tauri, or encrypted local file in dev mode)
- Config location: `~/.puffin/config.json` (dev) or `%APPDATA%/Puffin/config.json` (packaged)

### 7.6 Disconnect and Reconfigure
- "Disconnect" button in settings to remove sync configuration
- Clears stored folder ID and OAuth tokens
- App reverts to offline-only mode
- User can reconfigure with different folder or account

## Phase 8: Polish & Undo System

**Scope:** Soft delete, undo functionality, and UI refinements.

### 8.1 Soft Delete
- Mark transactions as is_deleted instead of removing
- Filter deleted transactions from normal views
- Optional: "Deleted items" view in settings

### 8.2 Undo System
- Action history stack (in-memory, cleared on page refresh)
- Undo button (Ctrl+Z keyboard shortcut)
- Undoable actions: categorise, split, unsplit, delete, budget change
- Visual feedback on undo

### 8.3 UI Polish
- Loading states for all async operations
- Error handling with user-friendly messages
- Empty states for inbox, transaction list
- Responsive design adjustments
- Keyboard navigation improvements

## Phase 9: Tauri Desktop Packaging

**Scope:** Package the Next.js application as a standalone Windows executable using Tauri, enabling single-file distribution without requiring Node.js installation.

### 9.1 Tauri Project Setup
- Add Tauri to existing project (`npm install @tauri-apps/cli @tauri-apps/api`)
- Configure `tauri.conf.json`:
  - App name: "Puffin"
  - Window title: "Puffin — Personal Budgeting"
  - Default window size: 1280x800, resizable
  - Single instance enforcement (prevent multiple windows accessing same database)
- Build target: Windows x64 portable executable (.exe)
- No installer required — single .exe file distribution

### 9.2 Build Pipeline Integration

**Development Workflow (Retained)**
- `npm run dev` — Standard Next.js development with hot reload (no Tauri)
- `npm run tauri dev` — Run inside Tauri shell with dev tools for testing native features
- `npm run tauri build` — Produce release .exe

**Build Process**
- Next.js builds to static output (`output: 'export'` in next.config.js)
- Tauri bundles static files with Rust-based webview
- Single .exe output, approximately 10-30MB
- No external dependencies required on target machine

### 9.3 Database Migration to Tauri Plugin
- Install `tauri-plugin-sql` for native SQLite access
- Update `lib/db.ts` abstraction layer to use Tauri plugin when running in packaged mode
- Implement runtime detection: check if running in Tauri context
- Maintain better-sqlite3 for development mode (faster iteration)
- Test all database operations in both modes

**Migration approach:**
```typescript
// lib/db.ts pseudocode
const isPackaged = !!window.__TAURI__;

export async function getTransactions() {
  if (isPackaged) {
    // Use tauri-plugin-sql
    const db = await Database.load('sqlite:puffin.db');
    return await db.select('SELECT * FROM transactions WHERE is_deleted = 0');
  } else {
    // Use better-sqlite3
    return db.prepare('SELECT * FROM transactions WHERE is_deleted = 0').all();
  }
}
```

### 9.4 Secure Token Storage
- Use `tauri-plugin-store` or Windows Credential Manager for OAuth refresh tokens
- Encrypt tokens at rest
- Fallback to encrypted local file for development mode

### 9.5 File System Locations
- Database: `%APPDATA%/Puffin/puffin.db`
- Backups: `%APPDATA%/Puffin/backups/`
- Config: `%APPDATA%/Puffin/config.json`
- Implement path resolution based on runtime environment

### 9.6 Window Close Handling
- Intercept window close event via Tauri API
- Trigger sync prompt before allowing close (existing Phase 7 requirement)
- Prevent close until sync completes or user explicitly skips
- Only show sync prompt if sync is configured

### 9.7 Auto-Update System

**Update Mechanism**
- Check for updates on app launch (GitHub Releases API)
- Compare local version against latest available
- If update available: non-blocking notification banner
  - "Version X.X available — [Download] [Dismiss]"
- Download button opens browser to release page (manual download)
- No silent/automatic installation

**Version Management**
- Version stored in `tauri.conf.json` and `package.json` (keep in sync)
- Display version in Settings page footer
- Release notes viewable from update notification (link to GitHub release)

### 9.8 Distribution via GitHub Releases

**Build Outputs**
- `Puffin-vX.X.X-windows-x64.exe` — Portable executable
- Optional: `Puffin-vX.X.X-windows-x64.zip` — Zipped for easier hosting

**Release Process**
- Build via GitHub Actions (optional automation for future)
- Upload to GitHub Releases as the primary distribution channel
- Users download new versions directly from GitHub Releases page
- Update download link on documentation/landing page (if applicable)

**GitHub Releases Benefits**
- Version history and release notes visible to users
- Direct download links for each version
- Changelog tracking through release descriptions
- Community engagement via release discussions

## Phase 10: Net Worth Tracking

**Scope:** Standalone net worth tracking page with periodic snapshots, visualization, and projection.

### 10.1 Database Schema and Types
- Add `net_worth_entry` table to SQLite schema
- Columns: id, recorded_at, assets_data (JSON), liabilities_data (JSON), total_assets, total_liabilities, net_worth, notes, created_at
- Create TypeScript types for NetWorthEntry and field structures
- JSON storage for customizable field labels and values

### 10.2 Database Operations Layer
- Create `lib/db/net-worth.ts` with CRUD functions
- Implement: createNetWorthEntry, getAllNetWorthEntries, getNetWorthEntryById, updateNetWorthEntry, deleteNetWorthEntry
- Handle JSON serialization/deserialization for assets_data and liabilities_data

### 10.3 API Routes
- `GET /api/net-worth` - List all entries (sorted by date descending)
- `POST /api/net-worth` - Create new entry with Zod validation
- `GET /api/net-worth/:id` - Get single entry
- `PUT /api/net-worth/:id` - Update entry
- `DELETE /api/net-worth/:id` - Hard delete entry

### 10.4 Record Net Worth Dialog
- Date picker for snapshot date
- Assets section with 12 fields (customizable labels):
  - Home, Car, Stocks 1-2, Superannuation 1-2, Cash, Offset, Asset 1-4
- Liabilities section with 7 fields (customizable labels):
  - Mortgage, Credit Card, Car Loan, Debt 1-4
- Each field: editable label input + currency value input
- Auto-calculate totals on save
- Support both create and edit modes (pre-fill for editing)

### 10.5 Entries Table
- Columns: Date, Total Assets, Total Liabilities, Net Worth, Actions
- Edit button opens pre-filled dialog
- Delete button shows confirmation dialog with prominent warning:
  - "This will permanently delete this net worth snapshot. This action cannot be undone."
- Sortable by date

### 10.6 Net Worth Chart with Projection
- Recharts LineChart matching dashboard styling
- Solid line for historical net worth values
- Linear regression calculation for trend projection
- Dashed line extending 5 years into future
- Responsive container, dark theme styling
- Empty state when no entries exist

### 10.7 Net Worth Page
- Header with title and "Record Net Worth" button
- Net Worth Chart component
- Entries Table component
- Loading and empty states
- Data refresh after create/edit/delete operations

### 10.8 Navigation Integration
- Add 'networth' to PageId type union
- Add "Net Worth" nav item to sidebar with Wallet icon
- Import and render NetWorthPage in app-shell switch

## Future Enhancements (Post-MVP)

- QIF file format support
- Custom date range views
- Export functionality
- Additional chart types
- Mobile-optimised views
- Transaction search
- Recurring transaction detection
- Goals/savings targets
- macOS and Linux builds
- Code signing certificate (removes Windows SmartScreen warnings)

# Logical Dependency Chain

## Layer 1: Foundation (Must Build First)
1. **Project setup, tooling & database schema** — Everything depends on this
2. **Database abstraction layer** — Enables future Tauri migration
3. **Local authentication** — Protects access before any data entry
4. **Basic API routes for transactions** — Required for any data entry
5. **Minimal UI shell with navigation** — Required frame for all features

## Layer 2: Data Entry (First Usable Frontend)
6. **Manual transaction entry** — Simplest way to get data in, validates data model works
7. **Transaction list view** — See what's in the database, confirm entry works
8. **CSV import with column mapping** — Primary data entry method
9. **Duplicate detection** — Prevents data quality issues early

## Layer 3: Organisation
10. **Category management (upper & sub)** — Required before categorisation
11. **Uncategorised inbox** — Central workflow for processing transactions
12. **Transaction categorisation UI** — Core functionality
13. **Transaction splitting** — Enhances categorisation flexibility

## Layer 4: Automation
14. **Auto-categorisation rules management** — Settings UI
15. **Rule application on import** — Reduces manual work

## Layer 5: Budgeting
16. **Monthly view with category aggregation** — Display spending by category
17. **Budget entry and comparison** — Core budgeting feature
18. **Budget carry-over and watermarks** — Convenience features

## Layer 6: Insights
19. **Analytics API endpoints** — Data for dashboard
20. **Dashboard layout and summary cards** — Quick overview
21. **Charts (line, pie)** — Visual trends
22. **Tabular reports (MoM, YoY)** — Detailed comparison

## Layer 7: Sync
23. **Google Drive API integration** — Technical foundation
24. **Folder URL input and validation** — User configuration
25. **Sync logic with backup** — Core sync functionality
26. **Sync UI and prompts** — User-facing sync controls
27. **Blocking close modal** — Ensures data safety (when sync configured)

## Layer 8: Refinement
28. **Soft delete implementation** — Safe deletion
29. **Undo system** — Error recovery
30. **UI polish and error handling** — Production readiness

## Layer 9: Desktop Distribution
31. **Tauri project setup and configuration** — Basic .exe builds
32. **Database abstraction swap to Tauri plugin** — Native SQLite access
33. **Secure token storage** — OAuth tokens in OS credential store
34. **Window close sync integration** — Native close event handling
35. **Auto-update notification system** — Version checking and prompts
36. **Build pipeline and release process** — Distributable artifacts

## Layer 10: Net Worth Tracking (Standalone Feature)
37. **Net worth database schema and types** — Table and TypeScript definitions
38. **Net worth CRUD operations** — Database layer with JSON handling
39. **Net worth API routes** — REST endpoints for entries
40. **Record net worth dialog** — Form with customizable asset/liability fields
41. **Entries table with delete warning** — List view with edit/delete actions
42. **Net worth chart with projection** — Line chart with 5-year linear regression
43. **Net worth page and navigation** — Combine components, add to sidebar

## Atomic Feature Builds

Each numbered item above is designed to be:
- Completable independently (given dependencies met)
- Testable in isolation
- Providing incremental value

**Earliest Usable State:** After Layer 2 (items 1-9), users can log in, import transactions and view them — basic expense tracking is functional.

**Core Value Delivered:** After Layer 5 (items 1-18), full budgeting workflow is available without sync or advanced analytics.

**Full MVP:** After Layer 8 (items 1-30), complete application running in development mode.

**Distributable Product:** After Layer 9 (items 1-36), standalone .exe ready for end users.

**Net Worth Tracking:** After Layer 10 (items 37-43), users can track net worth snapshots with visualization and 5-year projections.

# Risks and Mitigations

## Technical Challenges

### SQLite Concurrent Access
**Risk:** SQLite has limitations with concurrent writes; if sync doesn't complete properly, database corruption possible.
**Mitigation:** 
- Single-user access model (blocking sync on close)
- Local backup before every sync operation
- Implement WAL mode for better reliability

### Google Drive API Complexity
**Risk:** OAuth2 flow and token refresh can be complex; API rate limits possible.
**Mitigation:**
- Use established library (googleapis npm package)
- Implement token refresh handling
- Manual-only sync reduces API call frequency

### CSV Parsing Edge Cases
**Risk:** Bank CSV formats vary widely; parsing failures frustrate users.
**Mitigation:**
- Preview table allows users to verify parsing before import
- Column mapping puts control in user hands
- Start with simple CSV; add format support iteratively

### Database Abstraction Layer
**Risk:** Abstraction adds complexity; potential for bugs when swapping implementations.
**Mitigation:**
- Design abstraction early (Phase 1) before building features on top
- Comprehensive tests for database operations
- Test both implementations (better-sqlite3 and tauri-plugin-sql) in CI

## Tauri-Specific Risks

### WebView2 Availability
**Risk:** Older Windows 10 installations may not have WebView2 runtime.
**Mitigation:** 
- Tauri auto-prompts installation if missing
- Document requirement in release notes
- WebView2 is pre-installed on Windows 11 and recent Windows 10 updates

### Bundle Size
**Risk:** Including unnecessary dependencies inflates bundle.
**Mitigation:** 
- Use Tauri-native plugins (tauri-plugin-sql) instead of Node.js sidecars
- Tree-shake unused code in production build
- Target 10-30MB bundle size

### First-Launch Security Warnings
**Risk:** Windows SmartScreen may flag unsigned .exe as potentially unsafe.
**Mitigation:** 
- Document expected warning for users in release notes
- Consider code signing certificate for future releases (optional, has cost)
- Building reputation through downloads reduces warnings over time

## MVP Scope Risks

### Feature Creep
**Risk:** Adding features delays usable product.
**Mitigation:**
- Strict phase separation; complete each phase before moving on
- Layer 2 provides minimal usable product
- Future enhancements explicitly deferred

### Over-Engineering Sync
**Risk:** Complex sync logic delays core budgeting features.
**Mitigation:**
- Sync is Phase 7; full budgeting works without it
- Last-write-wins is simplest conflict resolution
- Can use manual file copy as interim solution

## Resource Constraints

### Single Developer
**Risk:** Limited time and attention; burnout possible.
**Mitigation:**
- Atomic feature builds allow progress in small increments
- Each layer delivers value; can pause between layers
- Avoid premature optimisation

### Testing Coverage
**Risk:** Bugs in financial calculations erode trust.
**Mitigation:**
- Prioritise tests for calculation logic (totals, percentages)
- Manual testing checklist for each phase
- Soft delete provides recovery from errors

# Appendix

## Default Upper Categories

| Name | Purpose | Included in Reports |
|------|---------|---------------------|
| Income | Salary, wages, other income | Yes (as denominator for %) |
| Expense | Day-to-day spending | Yes |
| Saving | Transfers to savings | Yes |
| Bill | Recurring fixed costs | Yes |
| Debt | Loan repayments | Yes |
| Transfer | Inter-account transfers | No (excluded) |

## CSV Import Column Options

- **Date** — Transaction date (required)
- **Description** — Transaction description/memo (required)  
- **Amount** — Transaction amount (required, negative = expense)
- **Ignore** — Column not imported

## Keyboard Shortcuts (Planned)

- `Ctrl+Z` / `Cmd+Z` — Undo last action
- `Ctrl+S` / `Cmd+S` — Trigger sync (when implemented)

## Technology Stack Summary

| Category | Choice | Rationale |
|----------|--------|-----------|
| Framework | Next.js 14+ | Full-stack React with API routes, App Router |
| Language | TypeScript | Type safety for financial calculations |
| Database | SQLite | Single file, portable, no server needed |
| DB Library (Dev) | better-sqlite3 | Synchronous, lightweight, fast iteration |
| DB Library (Packaged) | tauri-plugin-sql | Native Tauri integration, smaller bundle |
| Styling | Tailwind CSS | Rapid UI development, consistent design |
| Components | shadcn/ui | Accessible, customisable, Radix-based |
| Charts | Recharts | React-native, composable, good docs |
| Auth | bcrypt + session | Simple local password, no external auth |
| Testing | Vitest | Fast, ESM-native, Jest-compatible API |
| Package Manager | npm | Standard, no additional tooling |
| Desktop Packaging | Tauri 2.x | Lightweight, Rust-based, uses system webview |

## File Locations

| Context | Database | Backups | Config |
|---------|----------|---------|--------|
| Development | `./data/puffin.db` | `./data/backups/` | `./data/config.json` |
| Packaged (Windows) | `%APPDATA%/Puffin/puffin.db` | `%APPDATA%/Puffin/backups/` | `%APPDATA%/Puffin/config.json` |

## Google Drive Folder URL Format

Users copy the folder URL from their browser:
```
https://drive.google.com/drive/folders/1aBcDeFgHiJkLmNoPqRsTuVwXyZ
                                        └──────── Folder ID ────────┘
```

The app extracts and stores only the folder ID. The folder must be shared with the user's Google account with edit permissions.

## TypeScript Best Practices

### Use `as const` for Literal Types
TypeScript widens types by default. Use `as const` to preserve literal types and make objects read-only. Great for config files, routes, and exact values.
```typescript
// Bad - method becomes string
const request = { method: "get", url: "/api" };

// Good - method stays as "get"
const request = { method: "get", url: "/api" } as const;
```

### Discriminated Unions
Avoid interfaces with many optional properties. Create separate interfaces sharing a common "discriminant" property to enable type narrowing in switch statements.
```typescript
// Bad - optional properties everywhere
interface ApiState { status: string; data?: User; error?: string; }

// Good - discriminated union
type ApiState =
  | { status: "loading" }
  | { status: "success"; data: User }
  | { status: "error"; error: string };
```

### Use `satisfies` Over Type Annotations
Type annotations widen types and lose specifics. `satisfies` keeps literal types while validating against a type, and provides protection against typos.
```typescript
// Bad - loses literal type
const button: ButtonConfig = { variant: "primary" };
// button.variant is "primary" | "secondary" | "muted"

// Good - keeps literal type
const button = { variant: "primary" } satisfies ButtonConfig;
// button.variant is "primary"
```

### Template Literal Types for String Patterns
Enforce string patterns at compile time for CSS units, API endpoints, etc.
```typescript
type CSSUnit = "rem" | "px" | "em";
type CSSValue = `${number}${CSSUnit}`;
// "20px" works, "20" fails
```

### Utility Types
- `Required<T>` - makes all properties required
- `Partial<T>` - makes all properties optional
- `Omit<T, K>` - removes specific properties
- `Pick<T, K>` - selects specific properties

### Common Gotchas
- **Object keys are always strings** - even `{ 1: "a" }` has string keys
- **Empty `{}` type** - accepts any non-null value, use `Record<string, never>` for truly empty objects
- **Optional chaining returns `T | undefined`** - handle undefined before accessing nested properties

</PRD>
