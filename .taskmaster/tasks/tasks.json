{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Database Foundation",
        "description": "Initialize Next.js 14+ project with TypeScript, configure tooling, and establish SQLite database with core schema",
        "details": "1. Initialize Next.js 14+ with TypeScript and App Router: `npx create-next-app@latest puffin --typescript --tailwind --eslint --app`\n2. Install dependencies: `npm install better-sqlite3 @types/better-sqlite3 bcrypt @types/bcrypt tailwindcss @tailwindcss/forms`\n3. Configure shadcn/ui: `npx shadcn-ui@latest init`\n4. Set up Vitest: `npm install -D vitest @vitejs/plugin-react jsdom`\n5. Create database schema with tables: LocalUser, Transaction, UpperCategory, SubCategory, Budget, AutoCategoryRule, SyncLog\n6. Implement database initialization script with default upper categories (Income, Expense, Saving, Bill, Debt, Transfer)\n7. Create lib/database.ts with connection utilities and backup functions\n8. Set up project structure: app/, components/, lib/, types/\n9. Configure environment variables for database path",
        "testStrategy": "Unit tests for database connection, schema creation, and seeding. Verify all tables created correctly with proper foreign key constraints. Test database backup/restore functionality.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Next.js Project Initialization and Dependency Setup",
            "description": "Initialize Next.js 14+ project with TypeScript, install all required dependencies, and configure essential tooling including shadcn/ui and Vitest",
            "dependencies": [],
            "details": "Create new Next.js project using `npx create-next-app@latest puffin --typescript --tailwind --eslint --app`. Install core dependencies: better-sqlite3, bcrypt, tailwindcss packages. Configure shadcn/ui with `npx shadcn-ui@latest init`. Set up Vitest testing framework with React and jsdom support. Verify all packages install correctly and project builds without errors.",
            "status": "done",
            "testStrategy": "Verify project builds successfully, all dependencies resolve correctly, and basic Next.js routing works. Test that shadcn/ui components can be imported and Vitest can run basic tests."
          },
          {
            "id": 2,
            "title": "Database Schema Design and Table Creation",
            "description": "Design and implement SQLite database schema with all core tables including proper relationships and constraints",
            "dependencies": [
              1
            ],
            "details": "Create comprehensive database schema with tables: LocalUser, Transaction, UpperCategory, SubCategory, Budget, AutoCategoryRule, SyncLog. Define proper foreign key relationships, indexes, and constraints. Implement database initialization script that creates all tables and seeds default upper categories (Income, Expense, Saving, Bill, Debt, Transfer). Ensure schema supports soft deletes, UUIDs, and proper data types.",
            "status": "done",
            "testStrategy": "Test database schema creation, verify all tables exist with correct columns and constraints. Test foreign key relationships work properly. Verify default data seeding creates expected upper categories."
          },
          {
            "id": 3,
            "title": "Database Utilities and Connection Management",
            "description": "Implement database connection utilities, backup functions, and core database operations in lib/database.ts",
            "dependencies": [
              2
            ],
            "details": "Create lib/database.ts with SQLite connection management using better-sqlite3. Implement database initialization functions, backup/restore utilities, and connection pooling. Add error handling for database operations and transaction management. Create utility functions for common database operations like migrations and health checks.",
            "status": "done",
            "testStrategy": "Test database connection establishment, backup/restore functionality, and error handling. Verify connection pooling works correctly and database operations are properly transactional. Test migration utilities if implemented."
          },
          {
            "id": 4,
            "title": "Project Structure and Environment Configuration",
            "description": "Set up complete project directory structure and configure environment variables for database and application settings",
            "dependencies": [
              1
            ],
            "details": "Create organized project structure with app/, components/, lib/, types/ directories. Set up environment variable configuration for database path, authentication secrets, and other application settings. Create .env.example file with all required variables. Set up TypeScript path aliases and configure project-wide constants. Ensure proper gitignore and project documentation.",
            "status": "done",
            "testStrategy": "Verify all directories are created with proper structure. Test environment variable loading works correctly. Ensure TypeScript compilation works with path aliases and all project files are properly organized and accessible."
          }
        ]
      },
      {
        "id": 2,
        "title": "Local Authentication System",
        "description": "Implement bcrypt-based local password authentication with session management",
        "details": "1. Create LocalUser model with password_hash field using bcrypt\n2. Build login page with password input form\n3. Implement password setup flow for first-time users\n4. Create API routes: POST /api/auth/login, POST /api/auth/setup, POST /api/auth/logout\n5. Set up session management using HTTP-only cookies with iron-session or similar\n6. Create middleware to protect routes requiring authentication\n7. Hash passwords with bcrypt.hash() with salt rounds of 12\n8. Implement session validation and automatic logout\n9. Create auth context for managing login state",
        "testStrategy": "Test password hashing/verification, session creation/validation, protected route access, and first-time setup flow. Verify sessions persist across browser refreshes and expire appropriately.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "User Model and Password Hashing Implementation",
            "description": "Create LocalUser database model with secure bcrypt password hashing functionality",
            "dependencies": [],
            "details": "Implement LocalUser model with password_hash field, create bcrypt utility functions for hashing passwords with 12 salt rounds, implement password verification methods, and set up database schema with proper indexing for authentication queries.",
            "status": "done",
            "testStrategy": "Unit tests for password hashing/verification, database model validation, and bcrypt salt rounds verification"
          },
          {
            "id": 2,
            "title": "Login and Setup UI Components",
            "description": "Build responsive login page and first-time user password setup interface components",
            "dependencies": [],
            "details": "Create login form with password input validation, implement first-time setup flow UI with password confirmation, add form validation and error handling, integrate with shadcn/ui components for consistent styling, and implement loading states during authentication.",
            "status": "done",
            "testStrategy": "Component testing for form validation, UI state management, and accessibility compliance"
          },
          {
            "id": 3,
            "title": "Authentication API Routes",
            "description": "Implement secure API endpoints for login, logout, and password setup operations",
            "dependencies": [
              1
            ],
            "details": "Create POST /api/auth/login endpoint with bcrypt verification, implement POST /api/auth/setup for first-time password creation, build POST /api/auth/logout for session termination, add input validation with Zod schemas, and implement proper error handling with security considerations.",
            "status": "done",
            "testStrategy": "API endpoint testing with various payloads, authentication flow testing, and security vulnerability assessment"
          },
          {
            "id": 4,
            "title": "Session Management and Middleware",
            "description": "Set up secure session handling with HTTP-only cookies and authentication middleware",
            "dependencies": [
              3
            ],
            "details": "Implement iron-session or similar for secure session management, create HTTP-only cookie configuration, build authentication middleware for route protection, implement session validation and automatic logout functionality, and ensure proper session cleanup on logout.",
            "status": "done",
            "testStrategy": "Session persistence testing, middleware protection verification, and cookie security validation"
          },
          {
            "id": 5,
            "title": "Auth Context and Route Protection",
            "description": "Create authentication context provider and implement protected route system",
            "dependencies": [
              2,
              4
            ],
            "details": "Build React context for managing authentication state, implement useAuth hook for components, create protected route wrapper components, add automatic session validation on app load, implement login state persistence across browser refreshes, and integrate with navigation system.",
            "status": "done",
            "testStrategy": "Context state management testing, protected route access verification, and session persistence across browser refreshes"
          }
        ]
      },
      {
        "id": 3,
        "title": "Core API Routes and Data Models",
        "description": "Build essential CRUD API endpoints for transactions and categories with validation",
        "details": "1. Create Transaction model with UUID, date, description, amount, notes, sub_category_id, is_split, parent_transaction_id, is_deleted fields\n2. Implement API routes:\n   - GET/POST/PATCH/DELETE /api/transactions\n   - GET/POST/PATCH/DELETE /api/categories\n   - GET/POST/PATCH/DELETE /api/budgets\n3. Add input validation using Zod schemas\n4. Implement soft delete for transactions (is_deleted flag)\n5. Create database query functions for filtering, sorting, and aggregation\n6. Add error handling with proper HTTP status codes\n7. Implement transaction amount validation (negative for expenses, positive for income)\n8. Create utility functions for date handling and UUID generation",
        "testStrategy": "API endpoint testing with various payloads, validation error handling, soft delete functionality, and database constraint verification. Test CRUD operations for all models.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Transaction Data Model and Validation Schemas",
            "description": "Create the Transaction model with all required fields and implement Zod validation schemas for data integrity",
            "dependencies": [],
            "details": "Define Transaction model with UUID, date, description, amount, notes, sub_category_id, is_split, parent_transaction_id, is_deleted fields. Create comprehensive Zod schemas for transaction validation including amount validation (negative for expenses, positive for income), date format validation, and field length constraints. Set up TypeScript interfaces and ensure proper type safety throughout the application.",
            "status": "done",
            "testStrategy": "Unit tests for model validation, schema validation with various input combinations, and edge case testing for amount validation rules"
          },
          {
            "id": 2,
            "title": "Category and Budget Models",
            "description": "Implement Category and Budget data models with proper relationships and validation schemas",
            "dependencies": [],
            "details": "Create Category model with upper and sub-category structure, Budget model with category relationships and amount tracking. Implement Zod validation schemas for both models including category hierarchy validation, budget amount constraints, and proper foreign key relationships. Ensure referential integrity between categories, budgets, and transactions.",
            "status": "done",
            "testStrategy": "Test category hierarchy validation, budget constraints, and foreign key relationships with comprehensive unit tests"
          },
          {
            "id": 3,
            "title": "CRUD API Endpoints for Transactions",
            "description": "Build complete CRUD API routes for transactions with proper validation and error handling",
            "dependencies": [
              1
            ],
            "details": "Implement GET/POST/PATCH/DELETE endpoints for /api/transactions with comprehensive input validation using Zod schemas. Add query parameter support for filtering, sorting, and pagination. Implement transaction-specific business logic including amount validation, soft delete functionality, and parent-child transaction relationships for splits. Include proper HTTP status codes and error responses.",
            "status": "done",
            "testStrategy": "API endpoint testing with various payloads, validation error scenarios, and CRUD operation verification"
          },
          {
            "id": 4,
            "title": "CRUD API Endpoints for Categories and Budgets",
            "description": "Create API routes for category and budget management with validation and relationship handling",
            "dependencies": [
              2
            ],
            "details": "Implement GET/POST/PATCH/DELETE endpoints for /api/categories and /api/budgets with proper validation. Handle category hierarchy operations, budget-category relationships, and cascade operations when categories are deleted. Implement proper error handling for constraint violations and referential integrity issues. Add support for bulk operations and category reassignment.",
            "status": "done",
            "testStrategy": "Test category hierarchy operations, budget relationships, cascade deletes, and constraint validation"
          },
          {
            "id": 5,
            "title": "Database Query Utilities and Aggregation Functions",
            "description": "Create comprehensive database query functions for filtering, sorting, and data aggregation",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement utility functions for complex database queries including transaction filtering by date ranges, categories, and amounts. Create aggregation functions for budget tracking, spending summaries, and category totals. Add sorting utilities, pagination helpers, and search functionality. Include date handling utilities and UUID generation functions. Optimize queries for performance with proper indexing strategies.",
            "status": "done",
            "testStrategy": "Performance testing of queries, aggregation accuracy verification, and edge case testing for date ranges and filters"
          },
          {
            "id": 6,
            "title": "Error Handling and Soft Delete Implementation",
            "description": "Implement comprehensive error handling system and soft delete functionality across all models",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Create centralized error handling middleware with proper HTTP status codes, error messages, and logging. Implement soft delete functionality using is_deleted flag for transactions while maintaining referential integrity. Add error recovery mechanisms, validation error formatting, and proper error responses for API endpoints. Include database constraint error handling and transaction rollback mechanisms.",
            "status": "done",
            "testStrategy": "Error scenario testing, soft delete functionality verification, and database integrity testing under error conditions"
          }
        ]
      },
      {
        "id": 4,
        "title": "UI Shell and Navigation Framework",
        "description": "Create responsive layout with navigation and routing structure using shadcn/ui components",
        "details": "1. Install shadcn/ui components: `npx shadcn-ui@latest add button card input table navigation-menu`\n2. Create main layout component with navigation sidebar/header\n3. Implement routing structure with Next.js App Router:\n   - /dashboard (default landing page)\n   - /monthly (budget view)\n   - /inbox (uncategorised transactions)\n   - /settings (configuration)\n4. Create navigation component with active state highlighting\n5. Implement responsive design with mobile-friendly navigation\n6. Add loading states and error boundaries\n7. Create reusable UI components: PageHeader, DataTable, FormField\n8. Set up Tailwind CSS custom theme matching design requirements\n9. Add 'Last synced' banner placeholder in header",
        "testStrategy": "Test navigation between pages, responsive behavior on different screen sizes, loading states, and accessibility compliance. Verify routing works correctly with authentication.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Layout Components and Navigation Structure",
            "description": "Create main layout component with navigation sidebar/header and install required shadcn/ui components",
            "dependencies": [],
            "details": "Install shadcn/ui components (button, card, input, table, navigation-menu), create main layout component with navigation sidebar/header structure, implement navigation component with active state highlighting, and set up basic component architecture for the application shell",
            "status": "done",
            "testStrategy": "Test navigation component rendering, active state highlighting, and basic layout structure across different screen sizes"
          },
          {
            "id": 2,
            "title": "Routing Setup and Page Templates",
            "description": "Implement Next.js App Router structure with all required routes and page templates",
            "dependencies": [
              1
            ],
            "details": "Set up Next.js App Router with routes for /dashboard, /monthly, /inbox, /settings pages, create basic page templates for each route, implement loading states and error boundaries, and add 'Last synced' banner placeholder in header",
            "status": "done",
            "testStrategy": "Test navigation between all routes, verify loading states display correctly, and ensure error boundaries catch and display errors appropriately"
          },
          {
            "id": 3,
            "title": "Responsive Design and Reusable UI Components",
            "description": "Implement responsive design with mobile-friendly navigation and create reusable UI components",
            "dependencies": [
              1,
              2
            ],
            "details": "Create responsive design with mobile-friendly navigation patterns, build reusable UI components (PageHeader, DataTable, FormField), set up Tailwind CSS custom theme matching design requirements, and ensure consistent user experience across all screen sizes",
            "status": "done",
            "testStrategy": "Test responsive behavior on mobile, tablet, and desktop screen sizes, verify reusable components work consistently across different pages, and validate accessibility compliance"
          }
        ]
      },
      {
        "id": 5,
        "title": "Transaction Import System with CSV Processing",
        "description": "Build CSV import functionality with column mapping, preview, and duplicate detection",
        "details": "1. Create CSV parser using built-in Node.js capabilities or papaparse library\n2. Build file upload component with drag-and-drop support\n3. Implement column mapping interface with dropdowns for Date, Description, Amount, Ignore\n4. Create preview table showing parsed data with row selection checkboxes\n5. Add date format detection and parsing (DD/MM/YYYY, YYYY-MM-DD, MM/DD/YYYY)\n6. Implement duplicate detection algorithm (exact match: date + amount + description)\n7. Create import confirmation flow with duplicate warnings\n8. Build API route POST /api/transactions/import with file processing\n9. Add validation for required fields and amount format\n10. Handle encoding issues and malformed CSV gracefully",
        "testStrategy": "Test various CSV formats, date formats, duplicate detection accuracy, column mapping functionality, and error handling for malformed files. Verify import preview matches actual import results.",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "CSV Parsing and File Upload Components",
            "description": "Create CSV parser using papaparse library and build file upload component with drag-and-drop support",
            "dependencies": [],
            "details": "Implement CSV parser using papaparse library for robust parsing. Build file upload component with drag-and-drop interface, file type validation (CSV only), and file size limits. Handle encoding detection (UTF-8, ISO-8859-1) and provide user feedback during upload process.",
            "status": "done",
            "testStrategy": "Test various CSV formats, encoding types, file sizes, and drag-and-drop functionality. Verify error handling for non-CSV files and oversized files."
          },
          {
            "id": 2,
            "title": "Column Mapping Interface",
            "description": "Build interactive column mapping interface with dropdowns for Date, Description, Amount, and Ignore options",
            "dependencies": [
              1
            ],
            "details": "Create column mapping component with dropdown selectors for each CSV column. Support mapping to Date, Description, Amount, or Ignore fields. Include auto-detection based on column headers and data patterns. Provide visual feedback for required field mappings and validation warnings.",
            "status": "done",
            "testStrategy": "Test auto-detection accuracy, manual mapping changes, validation for required fields, and edge cases with unusual column headers."
          },
          {
            "id": 3,
            "title": "Data Preview and Validation",
            "description": "Create preview table showing parsed data with row selection checkboxes and field validation",
            "dependencies": [
              2
            ],
            "details": "Build preview table component displaying parsed CSV data with mapped columns. Include row selection checkboxes for selective import. Implement field validation for amount format, required fields, and data consistency. Show validation errors inline with clear messaging.",
            "status": "done",
            "testStrategy": "Test preview accuracy, row selection functionality, validation error display, and handling of malformed data rows."
          },
          {
            "id": 4,
            "title": "Date Format Detection and Parsing",
            "description": "Implement automatic date format detection and parsing for multiple formats including DD/MM/YYYY, YYYY-MM-DD, MM/DD/YYYY",
            "dependencies": [
              3
            ],
            "details": "Create date format detection algorithm that analyzes date patterns in CSV data. Support common formats: DD/MM/YYYY, YYYY-MM-DD, MM/DD/YYYY, and variations with different separators. Implement robust date parsing with fallback options and user confirmation for ambiguous dates.",
            "status": "done",
            "testStrategy": "Test date format detection accuracy across various formats, ambiguous date handling, and parsing edge cases like leap years and invalid dates."
          },
          {
            "id": 5,
            "title": "Duplicate Detection Algorithm",
            "description": "Implement duplicate detection algorithm using exact match on date, amount, and description fields",
            "dependencies": [
              4
            ],
            "details": "Create duplicate detection system that compares incoming transactions against existing database records. Use exact match algorithm on date + amount + description combination. Provide duplicate resolution options: skip, replace, or import as new. Include fuzzy matching for near-duplicates with user confirmation.",
            "status": "done",
            "testStrategy": "Test duplicate detection accuracy, false positive/negative rates, fuzzy matching effectiveness, and user resolution workflow."
          },
          {
            "id": 6,
            "title": "Import Processing and API Integration",
            "description": "Build API route POST /api/transactions/import with file processing and database integration",
            "dependencies": [
              5
            ],
            "details": "Create API endpoint for transaction import processing. Handle file upload, CSV parsing, validation, and database insertion. Implement batch processing for large files with progress tracking. Include transaction rollback on errors and comprehensive logging for debugging.",
            "status": "done",
            "testStrategy": "Test API endpoint with various file sizes, concurrent uploads, error scenarios, and database transaction integrity. Verify progress tracking accuracy."
          },
          {
            "id": 7,
            "title": "Error Handling and User Feedback",
            "description": "Implement comprehensive error handling and user feedback system for all import scenarios",
            "dependencies": [
              6
            ],
            "details": "Create robust error handling for malformed CSV files, encoding issues, validation failures, and API errors. Implement user-friendly error messages, progress indicators, and success confirmations. Include detailed import summary with counts of successful, skipped, and failed transactions.",
            "status": "done",
            "testStrategy": "Test error handling for various failure scenarios, user message clarity, progress indicator accuracy, and import summary correctness."
          }
        ]
      },
      {
        "id": 6,
        "title": "Transaction Management and Manual Entry",
        "description": "Create transaction list view and manual entry form with categorization support",
        "details": "1. Build transaction list component with sortable columns (date, description, amount, category)\n2. Create manual transaction entry form with date picker, description input, amount input, notes field\n3. Implement inline editing for transaction categorization\n4. Add transaction filtering and search functionality\n5. Create category dropdown component grouped by upper categories\n6. Build uncategorised inbox view filtering transactions where sub_category_id is null\n7. Add transaction count badges in navigation\n8. Implement transaction deletion with confirmation modal\n9. Create transaction detail view/modal for editing\n10. Add bulk operations for multiple transaction selection\n11. Embed transaction list in Monthly Budget view filtered by selected month\n12. Enable category click-to-filter in budget view\n13. Real-time budget summary updates when transaction categories change",
        "testStrategy": "Test manual entry validation, inline editing, filtering, sorting, and bulk operations. Verify category assignment updates correctly and uncategorised count updates in real-time. Test monthly budget integration with category filtering and real-time updates.",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Transaction List Component with Sorting and Filtering",
            "description": "Build the main transaction list component with sortable columns and basic filtering capabilities",
            "dependencies": [],
            "details": "Create a responsive table component with sortable columns for date, description, amount, and category. Implement column sorting with visual indicators (ascending/descending arrows). Add basic filtering controls for date ranges and transaction types. Include pagination or virtual scrolling for performance with large datasets. Use React.memo and useMemo for optimization.",
            "status": "done",
            "testStrategy": "Test sorting functionality on all columns, verify pagination performance with 10k+ transactions, test responsive behavior on mobile devices"
          },
          {
            "id": 2,
            "title": "Manual Entry Form with Validation",
            "description": "Create transaction entry form with comprehensive validation and user-friendly input controls",
            "dependencies": [],
            "details": "Build form with date picker, description input, amount input (with currency formatting), category dropdown, and notes field. Implement client-side validation for required fields, amount format, and date constraints. Add form state management with error handling and success feedback. Include keyboard shortcuts for quick entry and auto-focus management.",
            "status": "done",
            "testStrategy": "Test form validation rules, currency formatting, date picker functionality, and keyboard navigation. Verify error messages display correctly"
          },
          {
            "id": 3,
            "title": "Inline Editing and Categorization Interface",
            "description": "Implement inline editing capabilities and category assignment interface for transactions",
            "dependencies": [
              1
            ],
            "details": "Create inline editing for transaction fields with click-to-edit functionality. Build category dropdown component grouped by upper categories with search capability. Implement uncategorised inbox view filtering transactions where sub_category_id is null. Add real-time category assignment with optimistic updates and rollback on failure. Include transaction count badges in navigation.",
            "status": "done",
            "testStrategy": "Test inline editing saves correctly, category dropdown search functionality, uncategorised filter accuracy, and real-time count updates"
          },
          {
            "id": 4,
            "title": "Search and Filtering Functionality",
            "description": "Build comprehensive search and filtering system for transaction discovery",
            "dependencies": [
              1
            ],
            "details": "Implement full-text search across transaction descriptions and notes. Create advanced filtering options for date ranges, amount ranges, categories, and custom criteria. Add filter persistence in URL parameters and local storage. Include saved filter presets and quick filter buttons. Optimize search performance with debouncing and indexing strategies.",
            "status": "done",
            "testStrategy": "Test search accuracy across different fields, filter combinations, performance with large datasets, and filter persistence across page reloads"
          },
          {
            "id": 5,
            "title": "Bulk Operations and Transaction Management",
            "description": "Implement bulk selection and operations for efficient transaction management",
            "dependencies": [
              1,
              3
            ],
            "details": "Add checkbox selection for individual and bulk transaction selection. Create bulk operations toolbar with delete, categorize, and export actions. Implement transaction deletion with confirmation modal and undo functionality. Build transaction detail view/modal for comprehensive editing. Add keyboard shortcuts for bulk operations and include progress indicators for long-running operations.",
            "status": "done",
            "testStrategy": "Test bulk selection performance, confirmation modals, undo functionality, and keyboard shortcuts. Verify bulk operations complete successfully with proper error handling"
          },
          {
            "id": 6,
            "title": "Monthly Budget Transaction List Integration",
            "description": "Display a transaction list below the monthly budget view, filtered by the selected month",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create a reusable transaction list component that can be embedded in the Monthly Budget view. The list should automatically filter transactions to the currently selected month based on the budget view's month navigation. Include all transaction management features (sorting, inline category editing, add transaction button, edit/delete actions) except CSV import. The transaction list should always be visible below the budget summary cards. Use the existing CategoryProvider context for efficient category data sharing.",
            "status": "done",
            "testStrategy": "Test that transactions are correctly filtered by the selected month. Verify month navigation updates the transaction list. Test all transaction operations work correctly within the budget view context."
          },
          {
            "id": 7,
            "title": "Category Click-to-Filter in Budget View",
            "description": "Enable clicking on a category row in the budget summary to filter the transaction list to that category",
            "dependencies": [
              6
            ],
            "details": "Add click handlers to category rows in the budget summary section. When a category is clicked, filter the transaction list below to show only transactions in that category (while maintaining the month filter). Add visual indication of the active category filter with a clear/reset button. Implement smooth scroll to the transaction list when a category is selected. Allow clicking the same category again or a reset button to clear the category filter and show all month transactions.",
            "status": "done",
            "testStrategy": "Test category click filtering shows correct transactions. Verify clear filter functionality. Test that month filter is maintained when category filter is applied or removed."
          },
          {
            "id": 8,
            "title": "Real-time Budget Summary Updates",
            "description": "Update the budget summary in real-time when transaction categories are changed in the list below",
            "dependencies": [
              6
            ],
            "details": "When a user changes a transaction's category using the inline category selector in the Monthly Budget view, the budget summary cards above should update in real-time to reflect the new categorization. Implement optimistic UI updates for immediate feedback. Handle edge cases like moving a transaction from one category to another (both categories should update). Ensure the budget totals and progress bars recalculate correctly after category changes.",
            "status": "done",
            "testStrategy": "Test that changing a transaction category updates both the source and destination category totals. Verify budget summary totals recalculate correctly. Test optimistic updates and error rollback scenarios."
          }
        ]
      },
      {
        "id": 7,
        "title": "Category Management and Transaction Splitting",
        "description": "Build category CRUD interface and implement transaction splitting functionality",
        "details": "1. Create category management page in settings with upper and sub-category lists\n2. Implement upper category renaming functionality\n3. Build sub-category CRUD operations (create, rename, delete with transaction reassignment)\n4. Create transaction splitting modal allowing division into 2-3 parts\n5. Implement split validation ensuring amounts sum to original transaction\n6. Create child transactions linked to parent with parent_transaction_id\n7. Add unsplit functionality to reverse splits and restore original transaction\n8. Build category assignment interface for split portions\n9. Add visual indicators for split transactions in transaction lists\n10. Implement category deletion protection when transactions exist",
        "testStrategy": "Test category CRUD operations, transaction splitting math validation, unsplit functionality, and referential integrity. Verify split transactions display correctly and maintain proper relationships.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Category Management Interface and CRUD Operations",
            "description": "Build comprehensive category management page with upper and sub-category lists, including create, rename, and delete operations with proper validation and user feedback.",
            "dependencies": [],
            "details": "Create category management page in settings with upper and sub-category lists. Implement upper category renaming functionality. Build sub-category CRUD operations (create, rename, delete with transaction reassignment). Add form validation, error handling, and success notifications. Include category hierarchy display and management controls.",
            "status": "done",
            "testStrategy": "Test category creation, renaming, deletion, and hierarchy display. Verify form validation and error handling work correctly."
          },
          {
            "id": 2,
            "title": "Transaction Splitting Modal and User Interface",
            "description": "Create intuitive transaction splitting modal allowing users to divide transactions into 2-3 parts with amount inputs and category assignment for each split portion.",
            "dependencies": [
              1
            ],
            "details": "Create transaction splitting modal allowing division into 2-3 parts. Build dynamic form with amount inputs for each split. Add category assignment interface for split portions. Include visual indicators showing remaining amount to allocate. Implement responsive design and user-friendly controls for adding/removing split portions.",
            "status": "done",
            "testStrategy": "Test modal functionality, dynamic form behavior, category assignment, and visual feedback for amount allocation."
          },
          {
            "id": 3,
            "title": "Split Validation and Mathematical Operations",
            "description": "Implement robust validation system ensuring split amounts sum exactly to original transaction amount with proper error handling and user feedback.",
            "dependencies": [
              2
            ],
            "details": "Implement split validation ensuring amounts sum to original transaction. Add real-time validation feedback showing remaining amount. Handle decimal precision issues and rounding. Validate minimum split amounts and prevent zero-value splits. Include comprehensive error messages and validation state management.",
            "status": "done",
            "testStrategy": "Test mathematical validation, decimal precision handling, error messaging, and edge cases like zero amounts or oversplitting."
          },
          {
            "id": 4,
            "title": "Parent-Child Transaction Relationships and Data Model",
            "description": "Implement database schema and API logic for creating child transactions linked to parent with parent_transaction_id, maintaining referential integrity.",
            "dependencies": [
              3
            ],
            "details": "Create child transactions linked to parent with parent_transaction_id. Implement database schema changes for parent-child relationships. Build API endpoints for creating split transactions. Add visual indicators for split transactions in transaction lists. Ensure proper indexing and foreign key constraints for performance and data integrity.",
            "status": "done",
            "testStrategy": "Test parent-child relationship creation, database constraints, API endpoints, and visual indicators in transaction lists."
          },
          {
            "id": 5,
            "title": "Unsplit Functionality and Data Integrity Management",
            "description": "Build unsplit functionality to reverse transaction splits and restore original transaction while maintaining data consistency and handling edge cases.",
            "dependencies": [
              4
            ],
            "details": "Add unsplit functionality to reverse splits and restore original transaction. Implement data integrity checks before unsplitting. Handle cascading updates and maintain audit trail. Add confirmation dialogs and validation for unsplit operations. Ensure proper cleanup of child transactions and restoration of parent transaction state.",
            "status": "done",
            "testStrategy": "Test unsplit operations, data integrity maintenance, confirmation flows, and proper restoration of original transaction state."
          },
          {
            "id": 6,
            "title": "Category Deletion Protection and Transaction Reassignment",
            "description": "Implement category deletion protection when transactions exist and build transaction reassignment interface for safe category management.",
            "dependencies": [
              1,
              4
            ],
            "details": "Implement category deletion protection when transactions exist. Build transaction reassignment interface for moving transactions to different categories before deletion. Add bulk reassignment functionality and confirmation dialogs. Include transaction count validation and proper error handling for protected deletions. Ensure data consistency throughout all operations.",
            "status": "done",
            "testStrategy": "Test deletion protection logic, transaction reassignment functionality, bulk operations, and data consistency validation."
          }
        ]
      },
      {
        "id": 8,
        "title": "Auto-Categorisation Rules Engine",
        "description": "Create rule management interface and automatic categorisation system",
        "details": "1. Build rules management page with list of existing rules\n2. Create rule creation form with match text input and category selection\n3. Implement drag-and-drop reordering for rule priority\n4. Build rule application engine using 'contains exact text' matching\n5. Apply rules during CSV import processing (first match wins)\n6. Create API routes: GET/POST/PATCH/DELETE /api/rules\n7. Add rule testing functionality to preview matches\n8. Implement rule editing and deletion with confirmation\n9. Create rule statistics showing match counts\n10. Add rule validation preventing conflicts and empty rules",
        "testStrategy": "Test rule creation, priority ordering, automatic application during import, and rule matching accuracy. Verify rules apply in correct priority order and don't interfere with manual categorisation.",
        "priority": "medium",
        "dependencies": [
          5,
          7
        ],
        "status": "done",
        "completedAt": "2025-12-23",
        "subtasks": [
          {
            "id": 1,
            "title": "Rules Management Interface and CRUD Operations",
            "description": "Build the complete rules management interface with list view, creation form, and CRUD operations including API endpoints",
            "dependencies": [],
            "details": "Created rules management page (components/settings/rules-management.tsx) displaying existing rules with match text, category, priority, and match count. Built rule creation form with match text input and category selection dropdown. Implemented API routes (GET/POST/PATCH/DELETE /api/rules and /api/rules/[id]) for full CRUD operations. Added rule editing functionality with form pre-population and deletion with confirmation dialogs. Included form validation to prevent empty rules.",
            "status": "done",
            "testStrategy": "Test rule creation, editing, deletion, and API endpoints. Verify form validation prevents invalid rules and confirmation dialogs work correctly."
          },
          {
            "id": 2,
            "title": "Rule Priority System with Drag-and-Drop Reordering",
            "description": "Implement drag-and-drop functionality for rule priority ordering and priority-based rule application logic",
            "dependencies": [
              1
            ],
            "details": "Added drag-and-drop reordering capability to the rules list using native HTML5 drag API. Implemented priority field in rule data model with automatic reordering when rules are moved. Created visual indicators (drag handle icon, drag-over styling) for rule priority order. Priority updates are persisted via PATCH /api/rules API call with ruleIds array.",
            "status": "done",
            "testStrategy": "Test drag-and-drop functionality across different browsers, verify priority updates persist correctly, and ensure visual feedback during drag operations."
          },
          {
            "id": 3,
            "title": "Rule Matching Engine and Application Logic",
            "description": "Build the core rule matching engine with 'contains exact text' matching and integration with CSV import processing",
            "dependencies": [
              2
            ],
            "details": "Implemented rule application engine in lib/db/rules.ts using 'contains exact text' (case-insensitive) matching. Created applyRulesToDescription() and applyRulesToTransactions() functions with 'first match wins' strategy. Integrated with CSV import (app/api/transactions/import/route.ts) to automatically categorize transactions during import. Added autoCategorized count to ImportResult. Also added ability to apply rules to existing uncategorized transactions via POST /api/rules/[id].",
            "status": "done",
            "testStrategy": "Test rule matching accuracy, priority-based application, integration with import system, and performance with large datasets. Verify manual categorization takes precedence over automatic rules."
          },
          {
            "id": 4,
            "title": "Rule Testing and Statistics Features",
            "description": "Create rule testing functionality for previewing matches and statistics dashboard showing rule performance metrics",
            "dependencies": [
              3
            ],
            "details": "Built rule testing interface showing preview of matching uncategorized transactions when creating/editing rules. Created rule statistics showing match counts per rule. Added countMatchingTransactions() and testRule() functions. Implemented 'Apply to existing transactions' dialog that appears after creating a new rule, showing count of matching transactions with option to apply immediately. Added Zap button to manually apply any rule to existing transactions.",
            "status": "done",
            "testStrategy": "Test rule preview functionality, statistics accuracy, conflict detection algorithms, and performance metrics calculation. Verify batch testing handles large datasets efficiently."
          }
        ]
      },
      {
        "id": 9,
        "title": "Monthly Budget View and Budget Management",
        "description": "Build monthly budget interface with actual vs budget comparison and budget entry features",
        "details": "1. Create monthly view with month navigation (previous/next buttons)\n2. Build category aggregation API to calculate monthly totals by sub-category\n3. Implement budget entry interface with inline editing\n4. Create budget comparison display with red highlighting for over-budget items\n5. Add budget carry-over functionality from previous months\n6. Implement budget watermarks showing historical averages (3, 6 months)\n7. Build transaction list filtered by month with category editing\n8. Create click-through from category totals to filtered transaction view\n9. Add budget templates and quick-fill options\n10. Implement budget vs actual percentage calculations",
        "testStrategy": "Test monthly aggregation accuracy, budget entry and persistence, over-budget highlighting, carry-over functionality, and transaction filtering. Verify calculations match expected totals.",
        "priority": "high",
        "dependencies": [
          6,
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Monthly Navigation and Date Handling",
            "description": "Implement month navigation controls and date handling logic for the budget interface",
            "dependencies": [],
            "details": "Create monthly view component with previous/next navigation buttons, implement month state management, add date utilities for month calculations, and ensure proper month boundary handling across years",
            "status": "done",
            "testStrategy": "Test month navigation accuracy, year transitions, date calculations, and state persistence across navigation"
          },
          {
            "id": 2,
            "title": "Budget Aggregation and Calculation APIs",
            "description": "Build backend APIs for category aggregation and monthly budget calculations",
            "dependencies": [],
            "details": "Create API endpoints for monthly totals by sub-category, implement efficient database queries for aggregation, build budget vs actual calculation logic, and add historical average calculations for 3 and 6 month periods",
            "status": "done",
            "testStrategy": "Test aggregation accuracy with various data sets, verify calculation precision, and validate performance with large datasets"
          },
          {
            "id": 3,
            "title": "Budget Entry and Inline Editing Interface",
            "description": "Create user interface for budget entry with inline editing capabilities",
            "dependencies": [
              1
            ],
            "details": "Build budget entry forms with inline editing functionality, implement input validation for budget amounts, create save/cancel controls, and add keyboard shortcuts for efficient budget entry workflow",
            "status": "done",
            "testStrategy": "Test inline editing behavior, input validation, save/cancel functionality, and keyboard navigation"
          },
          {
            "id": 4,
            "title": "Budget vs Actual Comparison and Visualization",
            "description": "Implement budget comparison display with visual indicators and over-budget highlighting",
            "dependencies": [
              2,
              3
            ],
            "details": "Create budget vs actual comparison components, implement red highlighting for over-budget categories, add percentage calculations and progress bars, and build transaction list filtering by month with category editing capabilities",
            "status": "done",
            "testStrategy": "Test comparison accuracy, visual highlighting triggers, percentage calculations, and transaction filtering functionality"
          },
          {
            "id": 5,
            "title": "Budget Templates and Carry-over Functionality",
            "description": "Build budget templates system and implement budget carry-over from previous months",
            "dependencies": [
              2,
              3
            ],
            "details": "Create budget template creation and management interface, implement quick-fill options from templates, build carry-over logic for unused budget amounts, and add template application workflow with customization options",
            "status": "done",
            "testStrategy": "Test template creation/application, carry-over calculations, quick-fill accuracy, and template customization features"
          }
        ]
      },
      {
        "id": 10,
        "title": "Dashboard Analytics",
        "description": "Create analytics dashboard with charts for financial data visualization",
        "details": "1. Install Recharts: `npm install recharts`\n2. Build analytics API endpoints for dashboard data:\n   - Income percentage breakdown by sub-category\n   - Monthly spending trends\n   - Upper category trends over time\n3. Create dashboard layout with summary cards (total income, expenses, net)\n4. Implement charts: line chart for trends, pie chart for income allocation\n5. Add period selectors (3, 6, 12 months) for trend analysis",
        "testStrategy": "Test chart rendering with various data sets. Verify analytics calculations are accurate.",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Analytics API Endpoints and Data Aggregation",
            "description": "Build backend API endpoints to aggregate and serve analytics data for dashboard visualization",
            "dependencies": [],
            "details": "Install Recharts package and create API routes for income percentage breakdown by sub-category, monthly spending trends, and upper category trends over time. Implement data aggregation logic with proper date filtering and percentage calculations.",
            "status": "done",
            "testStrategy": "Test API endpoints with various date ranges and verify calculation accuracy for percentages and trend data"
          },
          {
            "id": 2,
            "title": "Dashboard Layout and Summary Cards",
            "description": "Create responsive dashboard layout with summary cards displaying key financial metrics",
            "dependencies": [
              1
            ],
            "details": "Build dashboard page layout with summary cards showing total income, expenses, and net balance. Implement responsive grid layout and ensure proper data binding from analytics APIs with loading states and error handling.",
            "status": "done",
            "testStrategy": "Test layout responsiveness across devices and verify summary card data updates correctly"
          },
          {
            "id": 3,
            "title": "Chart Implementation with Recharts",
            "description": "Implement interactive charts for data visualization using Recharts library",
            "dependencies": [
              1,
              2
            ],
            "details": "Create line charts for monthly trends and pie charts for income allocation breakdown. Add period selectors for 3, 6, and 12-month views. Implement chart interactivity, tooltips, and responsive design with proper data formatting.",
            "status": "done",
            "testStrategy": "Test chart rendering with various data sets, period selector functionality, and chart responsiveness"
          }
        ]
      },
      {
        "id": 11,
        "title": "Database Abstraction Layer",
        "description": "Create abstraction layer over database operations to enable seamless swap between better-sqlite3 (development) and tauri-plugin-sql (packaged app)",
        "details": "1. Create lib/db-abstraction.ts with unified interface for all database operations\n2. Abstract away direct better-sqlite3 calls behind common functions\n3. Design async-first interface to support both sync (better-sqlite3) and async (tauri-plugin-sql) implementations\n4. Export functions like getTransactions(), insertTransaction(), runQuery() that work in both contexts\n5. Implement runtime detection to check if running in Tauri context (window.__TAURI__)\n6. Create type definitions for database operation results\n7. Add connection pooling abstraction and transaction management\n8. Ensure all existing database code can migrate to use abstraction layer\n9. Write comprehensive tests for abstraction layer with mock implementations",
        "testStrategy": "Unit tests for all abstraction layer functions with mock implementations. Integration tests to verify existing functionality works through abstraction. Test both sync and async operation modes.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Database Abstraction Interface and Type Definitions",
            "description": "Design and implement the core abstraction interface with TypeScript definitions for unified database operations",
            "dependencies": [],
            "details": "Create lib/db-abstraction.ts with interface definitions for all database operations. Define TypeScript types for database results, connection objects, and query parameters. Create abstract base classes or interfaces that both better-sqlite3 and tauri-plugin-sql implementations will follow. Include type definitions for getTransactions(), insertTransaction(), runQuery() and other core database functions.",
            "status": "done",
            "testStrategy": "Unit tests for type checking and interface compliance. Mock implementations to verify interface completeness."
          },
          {
            "id": 2,
            "title": "Implement Runtime Environment Detection",
            "description": "Create runtime detection mechanism to identify whether running in Tauri context or development environment",
            "dependencies": [
              1
            ],
            "details": "Implement detection logic using window.__TAURI__ to determine runtime context. Create utility functions that can reliably detect the environment and return appropriate configuration. Handle edge cases where window object might not be available. Create fallback mechanisms and error handling for detection failures.",
            "status": "done",
            "testStrategy": "Test detection in both Tauri and browser environments. Mock window.__TAURI__ for testing different scenarios."
          },
          {
            "id": 3,
            "title": "Build Better-sqlite3 Implementation Layer",
            "description": "Create the better-sqlite3 specific implementation of the database abstraction interface for development mode",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement all database operations using better-sqlite3 API while conforming to the abstraction interface. Handle synchronous nature of better-sqlite3 by wrapping operations in Promise.resolve() for async compatibility. Implement connection management, query execution, and transaction handling specific to better-sqlite3. Ensure all operations match the expected interface signatures.",
            "status": "done",
            "testStrategy": "Integration tests with actual better-sqlite3 database. Verify all CRUD operations work correctly and return expected data structures."
          },
          {
            "id": 4,
            "title": "Build Tauri-plugin-sql Implementation Layer",
            "description": "Create the tauri-plugin-sql specific implementation of the database abstraction interface for packaged app mode",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement all database operations using tauri-plugin-sql API while conforming to the abstraction interface. Handle async nature of tauri-plugin-sql operations. Implement Database.load('sqlite:puffin.db') for connection, db.select() for queries, and db.execute() for mutations. Ensure error handling and result formatting matches the abstraction interface expectations.",
            "status": "pending",
            "testStrategy": "Integration tests in Tauri environment. Verify all operations work identically to better-sqlite3 implementation with same data integrity."
          },
          {
            "id": 5,
            "title": "Integrate Abstraction Layer and Migration Testing",
            "description": "Replace existing direct database calls with abstraction layer and implement comprehensive testing suite",
            "dependencies": [
              3,
              4
            ],
            "details": "Update all existing database code to use the new abstraction layer instead of direct better-sqlite3 calls. Implement connection pooling abstraction and transaction management. Create comprehensive test suite with mock implementations for both database backends. Add performance benchmarks and ensure no regression in functionality. Verify seamless switching between implementations.",
            "status": "pending",
            "testStrategy": "End-to-end tests verifying existing functionality works through abstraction. Performance tests comparing direct vs abstracted operations. Mock tests for both implementation paths."
          }
        ]
      },
      {
        "id": 12,
        "title": "Google Drive Sync and Configuration",
        "description": "Implement Google Drive synchronization with OAuth2 authentication, folder configuration, sync functionality, and UI management. Supports multi-computer sync with different Google accounts to a shared folder using Google Picker API.",
        "details": "1. Install Google APIs: `npm install googleapis`\n2. Create Google Drive configuration section in Settings page\n3. Build folder URL input field that extracts folder ID automatically from pasted URL\n4. Implement Google Drive OAuth2 authentication flow\n5. Implement folder validation on save:\n   - Authenticate with user's Google account (OAuth2 flow)\n   - List folder contents via Drive API to verify access\n   - Create/delete test file (.puffin-validation-test) to confirm write access\n   - Display success message with folder name confirmation\n   - Show clear error messages for failures (Folder not found, No access, Read-only access)\n6. Create sync functionality: push (upload) and pull (download) database\n7. Add local backup creation before sync operations\n8. Implement conflict detection and resolution strategies\n9. Build sync UI with manual trigger buttons and status indicators\n10. Implement blocking sync modal on app close\n11. Add 'Last synced' timestamp display in header\n12. Store folder ID in local config file (not SQLite database)\n13. Implement 'Not configured' state with setup prompt\n14. Hide sync-related UI (banner, prompts) until sync is configured\n15. Build 'Disconnect' button to remove sync configuration\n16. Clear stored folder ID and OAuth tokens on disconnect\n17. Support multi-user shared folder setup (independent validation per user)\n18. Store OAuth refresh token securely (encrypted local file in dev mode)\n19. Implement Google Picker API for secure folder/file selection\n20. Add first-run credentials setup wizard with encrypted storage\n21. Track local vs cloud database hashes for conflict detection\n22. Implement sync-required modal to enforce sync before editing",
        "testStrategy": "Test folder URL parsing and ID extraction. Verify OAuth2 flow and token refresh. Test validation flow with valid/invalid folders. Test sync upload/download functionality. Test backup creation and conflict resolution. Verify sync UI interactions and status updates. Test disconnect functionality and state transitions. Test multi-computer sync with different Google accounts. Verify sync-required modal blocks editing when cloud is newer.",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Google Drive Configuration UI Section",
            "description": "Build the Google Drive configuration section in the Settings page with folder URL input field and automatic folder ID extraction",
            "dependencies": [],
            "details": "Created sync-management.tsx component with full UI for Google Drive sync management, including authentication, folder selection (manual URL and Google Picker), sync actions, and disconnect functionality. Displays credentials setup wizard when credentials are not configured.",
            "status": "done",
            "testStrategy": "Test URL parsing with various Google Drive URL formats, verify folder ID extraction accuracy, and test input field validation"
          },
          {
            "id": 2,
            "title": "Implement OAuth2 Authentication Flow",
            "description": "Set up Google OAuth2 authentication flow for accessing user's Google Drive account with secure token storage",
            "dependencies": [
              1
            ],
            "details": "Implemented complete OAuth2 flow in lib/sync/oauth.ts with getOAuth2Client, getAuthenticatedClient, getAuthUrl, handleOAuthCallback. Modified to read credentials from SyncConfigManager first, falling back to environment variables. Optimized callback to save tokens immediately and fetch user email in background to prevent browser timeouts.",
            "status": "done",
            "testStrategy": "Test OAuth flow with valid/invalid credentials, verify token storage encryption, test token refresh functionality, and Google Drive API connectivity"
          },
          {
            "id": 3,
            "title": "Build Folder Validation System with Google Picker",
            "description": "Implement comprehensive folder validation including access verification and write permission testing via Google Drive API, plus Google Picker API for folder selection",
            "dependencies": [
              2
            ],
            "details": "Created validation system in lib/sync/google-drive.ts that authenticates with Google Drive API and validates folder access. Implemented Google Picker API integration in sync-management.tsx for secure folder selection, which grants drive.file scope access to selected folders.",
            "status": "done",
            "testStrategy": "Test validation with valid/invalid folders, verify write permission testing, and test error message display for different failure scenarios. Test Google Picker folder selection flow."
          },
          {
            "id": 4,
            "title": "Implement Configuration Storage and State Management",
            "description": "Build local configuration file storage for folder ID and implement UI state management for configured/unconfigured states",
            "dependencies": [
              3
            ],
            "details": "Created lib/sync/config.ts with SyncConfigManager for storing sync settings including folderId, folderName, lastSyncedAt, userEmail, localDbHash, cloudDbHash, hasLocalChanges, syncRequired, backupFileId. Implemented encrypted credential storage with saveCredentials, getCredentials, hasCredentials, clearCredentials methods.",
            "status": "done",
            "testStrategy": "Test configuration file creation and persistence, verify UI state transitions, and test sync UI hiding/showing based on configuration status"
          },
          {
            "id": 5,
            "title": "Sync Functionality (Upload/Download)",
            "description": "Create bidirectional sync functionality for database backup and restore with Google Drive",
            "dependencies": [
              3
            ],
            "details": "Implemented push (upload) in app/api/sync/push/route.ts with checkpointDatabase function to ensure SQLite WAL changes are merged before upload. Stores localDbHash and backupFileId after successful upload. Implemented pull (download) in app/api/sync/pull/route.ts that removes .db-wal and .db-shm files before replacing the main database.",
            "status": "done",
            "testStrategy": "Test upload/download operations, data integrity verification, and sync conflict scenarios"
          },
          {
            "id": 6,
            "title": "Conflict Detection and Hash Tracking",
            "description": "Implement database hash tracking and conflict detection mechanisms for sync operations",
            "dependencies": [
              5
            ],
            "details": "Added computeDbHash, updateSyncHashes, isSyncRequired, markLocalChanges methods to SyncConfigManager. Created app/api/sync/check/route.ts to compare local and cloud database states, returning syncRequired, reason (cloud_newer/local_changes/synced), and canEdit flags.",
            "status": "done",
            "testStrategy": "Test hash computation, conflict detection between local and cloud, and proper detection of cloud_newer and local_changes states"
          },
          {
            "id": 7,
            "title": "Sync UI and Status Management",
            "description": "Build user interface for sync management with status indicators and manual controls",
            "dependencies": [
              5,
              6
            ],
            "details": "Created sync-management.tsx with upload/download buttons, last synced timestamp display, connection status, and folder name display. Created credentials-setup.tsx with 3-step guided setup wizard for Google Cloud credentials. GET endpoint returns isAuthenticated, oauthConfigured, localDbHash, cloudDbHash, hasLocalChanges, syncRequired, backupFileId.",
            "status": "done",
            "testStrategy": "Test sync UI interactions, status updates, modal behavior, and error state handling"
          },
          {
            "id": 8,
            "title": "Build Disconnect Functionality",
            "description": "Implement disconnect button and cleanup process to remove sync configuration and clear stored tokens",
            "dependencies": [
              4
            ],
            "details": "Implemented disconnect in sync-management.tsx that calls DELETE /api/sync/config to clear folder configuration and DELETE /api/sync/oauth/logout to revoke OAuth tokens. Added 'Sign out of Google' button for authenticated-but-not-configured state.",
            "status": "done",
            "testStrategy": "Test disconnect functionality clears all stored data, verify UI returns to unconfigured state, and test multi-user scenario handling"
          },
          {
            "id": 9,
            "title": "Smart Conflict Detection with Local Change Tracking",
            "description": "Detect local changes by comparing current DB hash vs stored hash from last sync, enabling proper offline workflow support",
            "dependencies": [
              6
            ],
            "details": "Updated sync check API in app/api/sync/check/route.ts to detect six scenarios: not_configured, no_cloud_backup, never_synced, in_sync, local_only, cloud_only, conflict. Added syncedDbHash field to config to track hash at sync time. Added hasLocalChanges() and markSynced() methods to SyncConfigManager.",
            "status": "done",
            "testStrategy": "Test offline work detection, verify local changes are detected by hash comparison, test cloud-only changes detection"
          },
          {
            "id": 10,
            "title": "Conflict Resolution Dialog",
            "description": "Create dialog that shows cloud vs local timestamps and lets user choose which version to keep",
            "dependencies": [
              9
            ],
            "details": "Created SyncConflictDialog component in components/sync-conflict-dialog.tsx. Shows different UI based on scenario: cloud_only shows download button, local_only shows upload button, conflict/never_synced shows both options with clear warnings. Displays timestamps and change status.",
            "status": "done",
            "testStrategy": "Test dialog shows correct timestamps, verify download overwrites local, verify upload overwrites cloud, test user can make informed decision"
          },
          {
            "id": 11,
            "title": "Integrate Conflict Dialog into App Layout",
            "description": "Show conflict resolution dialog on app load when sync discrepancy is detected",
            "dependencies": [
              10
            ],
            "details": "Created SyncProvider context in hooks/use-sync-context.tsx. Integrated into AppShell component. Checks sync status on app load and shows SyncConflictDialog when needsResolution is true. Handles URL params from OAuth callback to auto-navigate to settings.",
            "status": "done",
            "testStrategy": "Test dialog appears on app load when conflict exists, test OAuth callback navigation works, test app proceeds normally after resolution"
          },
          {
            "id": 12,
            "title": "Lock Editing When Conflict Unresolved",
            "description": "Disable write operations when sync conflict exists and hasn't been resolved",
            "dependencies": [
              11
            ],
            "details": "Added canEdit flag from SyncContext to TransactionsPage. Disabled Import CSV, Add Transaction, Edit, Delete, Split buttons when canEdit is false. Added warning banner at top of transactions page when editing is locked.",
            "status": "done",
            "testStrategy": "Test add/edit buttons disabled during conflict, verify editing re-enabled after resolution, test API write operations blocked"
          },
          {
            "id": 13,
            "title": "Update Picker to Select Backup File for Multi-Account",
            "description": "Use Google Picker to select existing backup file for multi-account shared folder access",
            "dependencies": [
              8
            ],
            "details": "Implemented file-based sync mode via Google Picker. Added 'Connect to Existing Backup' option that allows selecting a puffin-backup.db file shared from another account. Fixed hasExtendedScope() to use exact scope matching (not substring). Added supportsAllDrives: true to Drive API calls for shared file access. Implemented progressive permission flow: standard scope (drive.file) first, prompts for extended scope (drive) when multi-account sync is needed. Added OAuth state parameter encoding to preserve scope level through callback. Added security improvements: machine-derived encryption keys, SHA-256 for DB hashing, SQL injection prevention in Drive queries, exponential backoff retry logic. Created comprehensive Vitest tests for sync module (config, oauth, google-drive, types/sync).",
            "status": "done",
            "testStrategy": "Test file selection with Picker, verify drive.file scope access works for selected file, test download from shared file with different Google account"
          }
        ]
      },
      {
        "id": 13,
        "title": "Tauri Project Setup and Build Pipeline",
        "description": "Initialize Tauri in the project and configure build pipeline for Windows portable executable distribution",
        "details": "1. Install Tauri CLI and API: npm install @tauri-apps/cli @tauri-apps/api\n2. Initialize Tauri in project: npx tauri init\n3. Configure tauri.conf.json:\n   - App name: 'Puffin'\n   - Window title: 'Puffin  Personal Budgeting'\n   - Default window size: 1280x800, resizable\n   - Single instance enforcement to prevent multiple windows accessing same database\n4. Set build target: Windows x64 portable executable (.exe)\n5. Configure Next.js for static export (output: 'export' in next.config.js)\n6. Add npm scripts:\n   - npm run tauri dev  Run inside Tauri shell with dev tools\n   - npm run tauri build  Produce release .exe\n7. Verify development workflow: npm run dev continues to work as standard Next.js\n8. Test Tauri dev mode runs correctly with webview\n9. Verify build produces single .exe file (target 10-30MB)\n10. Document build requirements and process",
        "testStrategy": "Verify Tauri initializes correctly. Test all npm scripts work as expected. Confirm development mode hot reload works. Verify production build produces valid .exe file. Test single instance enforcement prevents duplicate windows.",
        "priority": "low",
        "dependencies": [
          10,
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Initialize Tauri Framework",
            "description": "Install Tauri CLI and API packages, then initialize Tauri in the existing Next.js project",
            "dependencies": [],
            "details": "Run npm install @tauri-apps/cli @tauri-apps/api to add Tauri dependencies. Execute npx tauri init to scaffold Tauri configuration files and Rust backend structure. Verify src-tauri directory is created with proper Cargo.toml and main.rs files.",
            "status": "pending",
            "testStrategy": "Verify Tauri CLI installation by running tauri --version. Confirm src-tauri directory exists with valid Rust project structure."
          },
          {
            "id": 2,
            "title": "Configure Tauri Application Settings",
            "description": "Set up tauri.conf.json with Puffin app configuration including window settings and single instance enforcement",
            "dependencies": [
              1
            ],
            "details": "Configure tauri.conf.json with app name 'Puffin', window title 'Puffin  Personal Budgeting', default window size 1280x800 with resizable enabled. Enable single instance enforcement to prevent multiple windows accessing the same database. Set build target for Windows x64 portable executable.",
            "status": "pending",
            "testStrategy": "Verify configuration loads correctly and single instance enforcement prevents duplicate app launches. Test window dimensions and resizing behavior."
          },
          {
            "id": 3,
            "title": "Configure Next.js for Static Export",
            "description": "Modify Next.js configuration to support static export for Tauri webview integration",
            "dependencies": [
              1
            ],
            "details": "Update next.config.js to include output: 'export' configuration for static site generation. Ensure all dynamic routes and API endpoints are compatible with static export. Configure asset handling and routing for Tauri webview environment.",
            "status": "pending",
            "testStrategy": "Run next build to verify static export generates correctly without errors. Test that all pages and assets load properly in static mode."
          },
          {
            "id": 4,
            "title": "Set Up Development and Build Scripts",
            "description": "Add npm scripts for Tauri development and production builds with proper workflow integration",
            "dependencies": [
              2,
              3
            ],
            "details": "Add npm run tauri:dev script for development with hot reload and dev tools. Create npm run tauri:build script for production .exe generation. Ensure existing npm run dev continues to work for standard Next.js development. Configure scripts to handle both web and desktop development workflows.",
            "status": "pending",
            "testStrategy": "Test tauri:dev launches app with hot reload functionality. Verify tauri:build produces valid .exe file. Confirm standard Next.js dev mode still works independently."
          },
          {
            "id": 5,
            "title": "Validate Build Pipeline and Documentation",
            "description": "Test complete build process and create documentation for development workflow and build requirements",
            "dependencies": [
              4
            ],
            "details": "Execute full build pipeline to generate Windows portable executable. Verify .exe file size is within 10-30MB target range and runs independently. Test development workflow with both web and desktop modes. Document build requirements, dependencies, and step-by-step build process for team members.",
            "status": "pending",
            "testStrategy": "Verify final .exe runs on clean Windows system without dependencies. Test file size meets requirements. Validate documentation by following steps on different development environment."
          }
        ]
      },
      {
        "id": 14,
        "title": "Database Migration to Tauri Plugin",
        "description": "Implement tauri-plugin-sql integration and update database abstraction layer to use it in packaged mode",
        "details": "1. Install tauri-plugin-sql for native SQLite access in Tauri\n2. Update lib/db-abstraction.ts to detect Tauri context (window.__TAURI__)\n3. Implement Tauri-specific database operations using tauri-plugin-sql:\n   - Database.load('sqlite:puffin.db') for connection\n   - db.select() for queries\n   - db.execute() for mutations\n4. Maintain better-sqlite3 implementation for development mode\n5. Ensure all database operations work identically in both modes\n6. Handle async nature of tauri-plugin-sql (all operations return Promises)\n7. Update all API routes to use abstraction layer\n8. Test database operations in Tauri dev mode\n9. Test database operations in production build\n10. Verify data integrity across both implementations",
        "testStrategy": "Test all database operations in both better-sqlite3 and tauri-plugin-sql modes. Verify identical behavior and data integrity. Test concurrent operations and error handling in both modes. Performance comparison between implementations.",
        "priority": "low",
        "dependencies": [
          11,
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Configure tauri-plugin-sql",
            "description": "Install tauri-plugin-sql package and configure it in the Tauri application for native SQLite access",
            "dependencies": [],
            "details": "Install tauri-plugin-sql via npm/yarn, add it to Cargo.toml dependencies, configure the plugin in tauri.conf.json with appropriate permissions for database access, and ensure the plugin is properly initialized in the Tauri app setup",
            "status": "pending",
            "testStrategy": "Verify plugin installation by checking package.json and Cargo.toml. Test basic plugin initialization and connection establishment in Tauri dev mode"
          },
          {
            "id": 2,
            "title": "Implement Tauri Context Detection",
            "description": "Update database abstraction layer to detect when running in Tauri context versus development mode",
            "dependencies": [
              1
            ],
            "details": "Modify lib/db-abstraction.ts to check for window.__TAURI__ availability and create runtime detection logic that determines whether to use tauri-plugin-sql or better-sqlite3 implementation based on the execution environment",
            "status": "pending",
            "testStrategy": "Test context detection in both Tauri app and browser development environments. Verify correct implementation is selected based on runtime context"
          },
          {
            "id": 3,
            "title": "Implement Tauri-Specific Database Operations",
            "description": "Create tauri-plugin-sql implementation for all database operations using Database.load, db.select, and db.execute methods",
            "dependencies": [
              2
            ],
            "details": "Implement Tauri-specific database operations including Database.load('sqlite:puffin.db') for connection establishment, db.select() for query operations, and db.execute() for mutation operations. Ensure all operations handle the async nature of tauri-plugin-sql and return Promises consistently",
            "status": "pending",
            "testStrategy": "Test all CRUD operations using tauri-plugin-sql. Verify database connection, query execution, and mutation operations work correctly with proper error handling"
          },
          {
            "id": 4,
            "title": "Maintain Dual Implementation Compatibility",
            "description": "Ensure both better-sqlite3 and tauri-plugin-sql implementations provide identical functionality and behavior",
            "dependencies": [
              3
            ],
            "details": "Update the abstraction layer to maintain the existing better-sqlite3 implementation for development mode while ensuring both implementations provide identical results for all database operations. Handle the sync/async differences between implementations and ensure consistent error handling and data formatting",
            "status": "pending",
            "testStrategy": "Run identical test suites against both implementations. Compare results, performance, and error handling. Verify data integrity and consistency across both modes"
          },
          {
            "id": 5,
            "title": "Integration Testing and Production Validation",
            "description": "Test database operations in both Tauri dev mode and production builds to ensure complete functionality",
            "dependencies": [
              4
            ],
            "details": "Perform comprehensive testing of all database operations in Tauri development mode and create production builds to test packaged application behavior. Verify data integrity, concurrent operations, and error handling work correctly in both environments. Update all API routes to use the abstraction layer consistently",
            "status": "pending",
            "testStrategy": "Execute full test suite in Tauri dev mode and production builds. Test data migration, concurrent operations, error scenarios, and performance benchmarks. Verify all API routes work correctly through the abstraction layer"
          }
        ]
      },
      {
        "id": 15,
        "title": "Secure Token Storage and File System Handling",
        "description": "Implement secure OAuth token storage, eliminate hardcoded secrets, protect token endpoints, and configure proper file system locations for packaged app",
        "details": "1. Install tauri-plugin-store for secure key-value storage\n2. Implement secure OAuth refresh token storage:\n   - Use Windows Credential Manager via Tauri plugin in packaged mode\n   - Use encrypted local file for development mode\n   - Encrypt tokens at rest\n3. Remove hardcoded encryption key fallback ('puffin-dev-key-change-in-prod' in lib/sync/config.ts:22)\n4. Implement machine-derived encryption key:\n   - Generate unique key on first run using machine-specific data\n   - Store key derivation seed securely (not in source)\n   - Never commit keys to repository\n5. Protect token API endpoint (/api/sync/token):\n   - Add CSRF token validation\n   - Restrict to same-origin requests\n   - Consider short-lived token exchange\n6. Set restrictive file permissions on sensitive files:\n   - .sync-tokens.enc should be 600 (owner read/write only)\n   - sync-config.json should be 600\n7. Configure file system locations for packaged app:\n   - Database: %APPDATA%/Puffin/puffin.db\n   - Backups: %APPDATA%/Puffin/backups/\n   - Config: %APPDATA%/Puffin/config.json\n8. Implement path resolution based on runtime environment\n9. Create directory structure on first run if not exists\n10. Update all file operations to use resolved paths\n11. Clean credentials from repository:\n    - Remove .env.local from git history if committed\n    - Ensure Google OAuth credentials only loaded from environment at runtime\n12. Test file operations in sandboxed Tauri environment\n13. Verify backup creation works with new paths\n14. Document file locations and security practices for users",
        "testStrategy": "Test secure token storage and retrieval. Verify encryption of stored tokens. Verify hardcoded fallback key is removed. Test machine-derived key generation. Test token endpoint CSRF protection. Verify file permissions are restrictive. Test path resolution in both development and packaged modes. Verify directory creation on first run. Test backup functionality with new paths. Verify no secrets in git history.",
        "priority": "medium",
        "dependencies": [
          12,
          13,
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Configure Tauri Plugin Store",
            "description": "Install tauri-plugin-store for secure key-value storage and configure it for the application",
            "dependencies": [],
            "details": "Install tauri-plugin-store package, add it to Tauri configuration, and set up basic store initialization with proper permissions and security settings for encrypted storage",
            "status": "pending",
            "testStrategy": "Test store initialization, verify plugin loads correctly, and confirm basic read/write operations work"
          },
          {
            "id": 2,
            "title": "Implement Secure OAuth Token Storage",
            "description": "Create secure storage system for OAuth refresh tokens with environment-specific implementations",
            "dependencies": [
              1
            ],
            "details": "Implement Windows Credential Manager integration for packaged mode using Tauri plugin, create encrypted local file storage for development mode, and ensure tokens are encrypted at rest with proper key management",
            "status": "pending",
            "testStrategy": "Test token storage and retrieval in both development and packaged modes, verify encryption is working, and test credential manager integration"
          },
          {
            "id": 3,
            "title": "Configure Application File System Paths",
            "description": "Set up proper file system locations for packaged application with standardized paths",
            "dependencies": [],
            "details": "Configure paths for database (%APPDATA%/Puffin/puffin.db), backups (%APPDATA%/Puffin/backups/), and config (%APPDATA%/Puffin/config.json) with proper cross-platform path resolution",
            "status": "pending",
            "testStrategy": "Test path resolution on different operating systems, verify paths are created correctly, and confirm file access permissions"
          },
          {
            "id": 4,
            "title": "Implement Runtime Environment Path Resolution",
            "description": "Create path resolution system that works in both development and packaged environments",
            "dependencies": [
              3
            ],
            "details": "Build environment detection logic to determine if running in development or packaged mode, implement path resolution that returns appropriate paths for each environment, and create directory structure on first run if it doesn't exist",
            "status": "pending",
            "testStrategy": "Test path resolution in both development and packaged modes, verify directory creation works correctly, and test fallback mechanisms"
          },
          {
            "id": 5,
            "title": "Update File Operations and Validate Functionality",
            "description": "Update all existing file operations to use the new path resolution system and validate functionality",
            "dependencies": [
              2,
              4
            ],
            "details": "Refactor all database operations, backup creation, and config file handling to use resolved paths, test file operations in sandboxed Tauri environment, verify backup creation works with new paths, and document file locations for users",
            "status": "pending",
            "testStrategy": "Test all file operations with new paths, verify database works in both dev and packaged modes, test backup functionality, and validate sandboxed environment compatibility"
          },
          {
            "id": 6,
            "title": "Remove Hardcoded Encryption Key Fallback",
            "description": "Remove the insecure hardcoded fallback encryption key from lib/sync/config.ts",
            "dependencies": [],
            "details": "Remove the 'puffin-dev-key-change-in-prod' fallback at lib/sync/config.ts:22. Implement proper error handling when no encryption key is available. Add clear error message guiding user to configure encryption key. Ensure application fails safely rather than using weak default key.",
            "status": "pending",
            "testStrategy": "Verify application refuses to store tokens without proper key. Test error messages are clear and actionable. Verify no hardcoded secrets remain in codebase."
          },
          {
            "id": 7,
            "title": "Implement Machine-Derived Encryption Key",
            "description": "Generate unique encryption key per installation using machine-specific data",
            "dependencies": [
              6
            ],
            "details": "Generate unique encryption key on first run using combination of: machine ID, random salt stored in app data, and optional user-provided passphrase. Use PBKDF2 or Argon2 for key derivation. Store derivation seed (not the key) in secure location. For Tauri, use tauri-plugin-os to get machine identifiers. Ensure key derivation is deterministic for same machine.",
            "status": "pending",
            "testStrategy": "Test key is unique per installation. Verify key derivation is deterministic. Test tokens encrypted with derived key can be decrypted. Verify seed storage is secure."
          },
          {
            "id": 8,
            "title": "Protect Token API Endpoint",
            "description": "Add security protections to /api/sync/token endpoint to prevent token theft via XSS",
            "dependencies": [],
            "details": "Add CSRF token validation to /api/sync/token endpoint. Verify Origin/Referer headers match application origin. Consider implementing short-lived token exchange where frontend receives time-limited token. Add rate limiting to prevent brute force. Log token access for security auditing.",
            "status": "pending",
            "testStrategy": "Test CSRF protection blocks cross-origin requests. Verify same-origin requests succeed. Test rate limiting works. Verify audit logs capture token access."
          },
          {
            "id": 9,
            "title": "Set Restrictive File Permissions",
            "description": "Configure restrictive file permissions on sensitive files to prevent unauthorized access",
            "dependencies": [
              2
            ],
            "details": "Set file permissions to 600 (owner read/write only) for: .sync-tokens.enc, sync-config.json, .sync-credentials.enc. Implement permission setting in saveTokens(), saveConfig(), and saveCredentials() functions. For Windows, use appropriate ACL settings. Verify permissions on file read and warn if too permissive.",
            "status": "pending",
            "testStrategy": "Verify files are created with correct permissions. Test other users cannot read sensitive files. Test warning appears if permissions are too permissive."
          },
          {
            "id": 10,
            "title": "Clean Credentials from Repository",
            "description": "Remove any committed credentials from git history and establish secure credential handling",
            "dependencies": [],
            "details": "Audit git history for committed secrets (.env.local, .env with real values). Use git filter-branch or BFG Repo-Cleaner to remove secrets from history if found. Update .gitignore to ensure .env* files are excluded. Create .env.example with placeholder values only. Document that credentials must be set via environment variables at runtime, not in files.",
            "status": "pending",
            "testStrategy": "Verify no secrets in git history using git log searches. Verify .env files are gitignored. Test application works with environment variables only."
          },
          {
            "id": 11,
            "title": "Document Security Practices",
            "description": "Create documentation for secure deployment and credential management",
            "dependencies": [
              6,
              7,
              8,
              9,
              10
            ],
            "details": "Document: 1) How encryption keys are derived and stored, 2) Required environment variables for Google OAuth, 3) File permission requirements, 4) Security considerations for multi-user systems, 5) How to rotate/revoke compromised tokens, 6) Backup security considerations. Add security section to README or create SECURITY.md.",
            "status": "pending",
            "testStrategy": "Review documentation for completeness. Verify all security features are documented. Test that following docs results in secure setup."
          }
        ]
      },
      {
        "id": 16,
        "title": "Window Close Handling, Auto-Update, and GitHub Releases Distribution",
        "description": "Implement native window close sync prompt, auto-update notification system via GitHub Releases API, and finalize GitHub Releases distribution pipeline",
        "details": "1. Intercept window close event via Tauri API\n2. Trigger sync prompt before allowing close (reuse Phase 7 modal)\n3. Prevent close until sync completes or user explicitly skips\n4. Only show sync prompt if sync is configured\n5. Implement auto-update checking:\n   - Check GitHub Releases API on app launch\n   - Compare local version against latest available\n   - Display non-blocking notification banner if update available\n   - 'Version X.X available  [Download] [Dismiss]'\n   - Download button opens browser to release page\n6. Display version number in Settings page footer\n7. Keep version in sync between tauri.conf.json and package.json\n8. Configure build outputs:\n   - Puffin-vX.X.X-windows-x64.exe (portable executable)\n   - Optional: .zip for easier hosting\n9. Document release process for GitHub Releases\n10. Optional: Set up GitHub Actions for automated builds",
        "testStrategy": "Test window close interception and sync prompt display. Verify close is blocked until sync completes or skips. Test auto-update version comparison logic. Verify notification banner UI. Test download link opens correctly. Verify version display in Settings.",
        "priority": "low",
        "dependencies": [
          12,
          15
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Window Close Event Interception",
            "description": "Set up Tauri window close event handling with sync prompt integration",
            "dependencies": [],
            "details": "Use Tauri's window API to intercept close events, implement beforeunload-style handling that triggers sync prompt modal (reusing Phase 7 modal component), and prevent window close until sync completes or user explicitly skips",
            "status": "pending",
            "testStrategy": "Test window close interception works correctly, verify sync prompt displays when sync is configured, test close prevention until sync completion"
          },
          {
            "id": 2,
            "title": "Build Auto-Update Version Checking System",
            "description": "Implement GitHub Releases API integration for version comparison and update detection",
            "dependencies": [],
            "details": "Create service to check GitHub Releases API on app launch, compare local version from package.json against latest available release, implement version parsing and comparison logic with semantic versioning support",
            "status": "pending",
            "testStrategy": "Test version comparison logic with various version formats, verify API calls work correctly, test handling of network failures and API rate limits"
          },
          {
            "id": 3,
            "title": "Create Update Notification Banner UI",
            "description": "Build non-blocking notification banner component for displaying available updates",
            "dependencies": [
              2
            ],
            "details": "Design and implement notification banner with 'Version X.X available  [Download] [Dismiss]' format, integrate download button that opens browser to GitHub release page, add dismiss functionality with local storage persistence",
            "status": "pending",
            "testStrategy": "Test banner display and positioning, verify download button opens correct release page, test dismiss functionality persists across sessions"
          },
          {
            "id": 4,
            "title": "Implement Version Display and Synchronization",
            "description": "Add version number display in Settings page and ensure version sync between config files",
            "dependencies": [],
            "details": "Display current version number in Settings page footer, create build script or process to keep version synchronized between tauri.conf.json and package.json, implement version reading from appropriate source in both dev and production modes",
            "status": "pending",
            "testStrategy": "Verify version displays correctly in Settings, test version sync mechanism works during build process, validate version reading in different environments"
          },
          {
            "id": 5,
            "title": "Configure GitHub Releases Distribution Pipeline",
            "description": "Set up build outputs configuration and establish GitHub Releases as the primary distribution channel",
            "dependencies": [
              4
            ],
            "details": "Configure Tauri build to generate Puffin-vX.X.X-windows-x64.exe portable executable for GitHub Releases distribution. Optionally create .zip packaging for easier hosting. Document complete release process with GitHub Releases as the primary distribution channel. Set up GitHub Actions for automated builds and releases. Create release template with changelog format.",
            "status": "pending",
            "testStrategy": "Test build output generation with correct naming convention, verify executable works as portable app, validate release documentation completeness"
          }
        ]
      },
      {
        "id": 17,
        "title": "Import Enhancement - Handle Missing Descriptions",
        "description": "Allow CSV import to proceed with rows that have missing descriptions by using a default value",
        "details": "1. Update CSV parsing logic to detect missing/empty description fields\n2. Apply default value 'No description' for transactions with empty descriptions\n3. Update import preview to show rows with missing descriptions (with visual indicator)\n4. Ensure validation does not reject rows with empty descriptions\n5. Add option in import settings to customize the default description value\n6. Update import summary to count rows that used default description\n7. Test with various CSV formats where description column is empty or missing",
        "testStrategy": "Test CSV import with files containing empty description fields. Verify default value is applied correctly. Test preview shows rows with defaulted descriptions. Verify import summary accurately reports defaulted rows.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "done",
        "completedAt": "2025-12-21",
        "subtasks": [
          {
            "id": 1,
            "title": "Update CSV Parsing to Handle Empty Descriptions",
            "description": "Modify the CSV parser to accept rows with missing or empty description fields",
            "dependencies": [],
            "details": "Updated import-wizard.tsx to detect empty descriptions during parsing. Empty descriptions are replaced with 'No description' default. Added hasDefaultDescription flag to ParsedRow type to track which rows used the default.",
            "status": "done",
            "testStrategy": "Test parsing CSVs with empty description fields, null values, and whitespace-only descriptions"
          },
          {
            "id": 2,
            "title": "Apply Default Description Value",
            "description": "Implement logic to apply 'No description' default value for empty descriptions",
            "dependencies": [
              1
            ],
            "details": "Default value 'No description' is applied in import-wizard.tsx during row parsing. Preview table (preview-table.tsx) shows defaulted descriptions with italic styling and text-slate-400 color to visually distinguish them from user-provided descriptions.",
            "status": "done",
            "testStrategy": "Verify default value is applied correctly during import. Test that preview shows visual indicator for defaulted rows."
          },
          {
            "id": 3,
            "title": "Update Import Summary and Validation",
            "description": "Update validation to allow empty descriptions and report defaulted rows in summary",
            "dependencies": [
              2
            ],
            "details": "Removed validation that rejected empty descriptions. Rows with empty descriptions are now auto-selected for import (errors.length === 0). The hasDefaultDescription field in types/import.ts tracks defaulted rows.",
            "status": "done",
            "testStrategy": "Test import summary accurately counts and reports defaulted description rows. Verify validation no longer rejects empty descriptions."
          }
        ]
      },
      {
        "id": 18,
        "title": "Transfer Sub-Category Transaction Handling",
        "description": "Transactions tagged with any transfer sub-category should be greyed out and excluded from all calculations like split parent transactions",
        "details": "1. Identify all sub-categories under the 'Transfer' upper category\n2. Update transaction display logic to grey out transactions with transfer sub-categories\n3. Modify all calculation/aggregation queries to exclude transfer sub-category transactions:\n   - Monthly budget totals\n   - Category summaries\n   - Dashboard analytics\n   - Income/expense totals\n4. Apply same visual styling as split parent transactions (greyed, de-emphasized)\n5. Ensure transfer transactions are still visible in transaction lists but clearly marked\n6. Update any existing tests to account for transfer exclusion logic\n7. Add tooltip or indicator explaining why transfer transactions are excluded",
        "testStrategy": "Test that transfer sub-category transactions are visually greyed. Verify all calculations exclude transfer transactions. Test budget views, dashboard analytics, and category summaries all properly exclude transfers. Verify transfer transactions remain visible but de-emphasized in lists.",
        "priority": "high",
        "dependencies": [
          6,
          7,
          9
        ],
        "status": "done",
        "completedAt": "2025-12-21",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify Transfer Sub-Categories in Queries",
            "description": "Create query logic to identify transactions belonging to transfer upper category",
            "dependencies": [],
            "details": "Transaction queries include upper_category_type via LEFT JOIN, allowing identification of transfer transactions. The upper_category_type field is returned in TransactionWithCategory type.",
            "status": "done",
            "testStrategy": "Test that transfer sub-categories are correctly identified. Verify query returns all and only transactions in transfer category."
          },
          {
            "id": 2,
            "title": "Update Calculation Queries to Exclude Transfers",
            "description": "Modify all aggregation and calculation queries to exclude transfer transactions",
            "dependencies": [
              1
            ],
            "details": "Updated lib/db/budgets.ts to exclude transfer categories from budget calculations using uc.type NOT IN ('income', 'transfer'). Updated initializeMonthlyBudgets and createBudgetsFrom12MonthAverage to exclude transfer categories. Monthly budget page groups transfer categories separately from expense categories.",
            "status": "done",
            "testStrategy": "Verify budget totals exclude transfer transactions. Test dashboard analytics, category summaries all properly exclude transfers."
          },
          {
            "id": 3,
            "title": "Apply Visual Styling for Transfer Transactions",
            "description": "Grey out transfer sub-category transactions in transaction lists with visual indicator",
            "dependencies": [
              1
            ],
            "details": "Applied opacity-50 styling to transfer transactions in monthly-transaction-list.tsx (same as split parents). Added amber TRANSFER badge with tooltip explaining exclusion from calculations. Monthly budget page displays transfer categories in a separate read-only section with blue styling.",
            "status": "done",
            "testStrategy": "Test visual styling matches split parent transactions. Verify tooltip displays correct explanation. Test across all transaction list views."
          }
        ]
      },
      {
        "id": 19,
        "title": "Transaction Source Field",
        "description": "Add a new 'source' field for transactions to track the origin (e.g., Bendigo, Maxxia) with filtering and import capabilities",
        "details": "1. Add 'source' column to Transaction table in database schema\n2. Create Source management in settings (CRUD for source names)\n3. Add source dropdown to manual transaction entry form\n4. Add source selection option in CSV import wizard (apply to all imported rows)\n5. Implement source filter in transaction list views\n6. Add source to transaction search functionality\n7. Display source as a tag/badge on transaction rows\n8. Allow bulk update of source for selected transactions\n9. Update API endpoints to support source field\n10. Add source to transaction detail view/edit modal\n11. Consider adding source to import column mapping (optional per-row source)",
        "testStrategy": "Test source field CRUD operations. Verify source can be set during manual entry and import. Test filtering by source works correctly. Verify search includes source field. Test bulk source update functionality.",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "done",
        "completedAt": "2025-12-21",
        "subtasks": [
          {
            "id": 1,
            "title": "Database Schema and API Updates for Source Field",
            "description": "Add source column to Transaction table and update API endpoints",
            "dependencies": [],
            "details": "Added 'source' table and 'source_id' column to Transaction table via database migration (lib/db/index.ts with schema_version tracking). Created /api/sources and /api/sources/[id] API routes. Updated transaction API endpoints to handle source_id field. Updated TypeScript types (types/database.ts) and Zod validation schemas (lib/validations.ts). Database functions in lib/db/sources.ts for CRUD operations.",
            "status": "done",
            "testStrategy": "Test database migration creates column correctly. Verify API endpoints accept and return source field."
          },
          {
            "id": 2,
            "title": "Source Management UI",
            "description": "Create settings interface for managing source names (CRUD operations)",
            "dependencies": [
              1
            ],
            "details": "Created SourceManagement component (components/settings/source-management.tsx) integrated into CategoryManagement settings page. Implemented create, rename, and delete operations for sources with confirmation dialogs. When deleting sources, transactions are updated to have source_id = NULL.",
            "status": "done",
            "testStrategy": "Test CRUD operations for sources. Verify source names persist correctly. Test deletion protection if sources are in use."
          },
          {
            "id": 3,
            "title": "Source Selection in Transaction Entry and Import",
            "description": "Add source dropdown to manual entry form and import wizard",
            "dependencies": [
              2
            ],
            "details": "Created SourceSelector component (components/transactions/source-selector.tsx) with create-inline capability. Added source dropdown to TransactionForm (transaction-form.tsx). Added source selection to CSV import wizard (import-wizard.tsx) using shadcn Select component to apply source to all imported rows.",
            "status": "done",
            "testStrategy": "Test source can be selected during manual entry. Verify import wizard applies source to all rows. Test optional per-row source mapping."
          },
          {
            "id": 4,
            "title": "Source Filtering and Display",
            "description": "Implement source filter in transaction lists and display source as tag/badge",
            "dependencies": [
              1,
              2
            ],
            "details": "Added sourceId to FilterValues type and FiltersPopover component with SourceSelector. Added source filter to transactions API. Display source as blue tag/badge on transaction rows in both transactions page and monthly-transaction-list. Source name joined via LEFT JOIN in transaction queries. Note: Bulk source update not yet implemented.",
            "status": "done",
            "testStrategy": "Test filtering by source works correctly. Verify search includes source. Test source display on transaction rows. Test bulk update functionality."
          }
        ]
      },
      {
        "id": 20,
        "title": "Display Transaction Notes in UI",
        "description": "Show transaction notes directly under the description in the transaction list with smaller, de-emphasized styling",
        "details": "1. Update transaction row component to display notes field\n2. Position notes directly under the description text\n3. Apply smaller font size (e.g., text-sm or text-xs)\n4. Apply de-emphasized styling (grey color, lighter weight)\n5. Truncate long notes with ellipsis and show full notes on hover/tooltip\n6. Ensure notes don't disrupt row layout or spacing\n7. Handle empty notes gracefully (no extra space)\n8. Apply consistent styling across all transaction list views (inbox, monthly, etc.)\n9. Consider adding ability to expand/collapse notes if very long",
        "testStrategy": "Verify notes display correctly under descriptions. Test styling is appropriately de-emphasized. Test truncation and tooltip for long notes. Verify empty notes don't affect layout. Test across all transaction list views.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "completedAt": "2025-12-21",
        "subtasks": [
          {
            "id": 1,
            "title": "Update Transaction Row Component Layout",
            "description": "Modify transaction row to include notes below description",
            "dependencies": [],
            "details": "Implemented in monthly-transaction-list.tsx. Notes display under description in a space-y-0.5 container. Empty notes handled gracefully with conditional rendering. Layout applied consistently across transaction list views.",
            "status": "done",
            "testStrategy": "Test layout with and without notes. Verify empty notes don't create extra whitespace."
          },
          {
            "id": 2,
            "title": "Apply Notes Styling",
            "description": "Style notes with smaller, de-emphasized grey font",
            "dependencies": [
              1
            ],
            "details": "Applied text-xs and text-slate-500 styling to notes in monthly-transaction-list.tsx. Notes are truncated with max-w-[280px] and ellipsis.",
            "status": "done",
            "testStrategy": "Verify styling is appropriately smaller and de-emphasized. Test visual consistency across light/dark modes if applicable."
          },
          {
            "id": 3,
            "title": "Handle Long Notes with Truncation",
            "description": "Truncate long notes with ellipsis and show full content on hover",
            "dependencies": [
              2
            ],
            "details": "Implemented truncation with truncate class and max-w-[280px]. Full notes shown via title attribute tooltip on hover.",
            "status": "done",
            "testStrategy": "Test truncation triggers at correct length. Verify tooltip shows full notes. Test across all transaction list views (inbox, monthly, etc.)."
          }
        ]
      },
      {
        "id": 21,
        "title": "Net Worth Tracking Page",
        "description": "Add a standalone Net Worth page with a table of historical snapshots, a line chart with 5-year projection, and a form to record assets and liabilities at a point in time with customizable field labels",
        "details": "1. Create net_worth_entry table in database schema with: id, recorded_at, assets_data (JSON), liabilities_data (JSON), total_assets, total_liabilities, net_worth, notes, created_at\n2. Assets fields: Home (at purchase), Car (current value), Stocks 1, Stocks 2, Superannuation 1, Superannuation 2, Cash, Offset, Asset 1-4\n3. Liabilities fields: Mortgage, Credit Card Debt, Car Loan, Debt 1-4\n4. Store customizable labels with values in JSON format\n5. Build RecordNetWorthDialog with editable labels and value inputs for each field\n6. Create EntriesTable with date, totals, net worth, and edit/delete actions\n7. Delete action must show confirmation dialog with warning\n8. Build NetWorthChart using Recharts LineChart with solid historical line\n9. Add dashed projection line using linear regression for 5 years ahead (only when 2+ data points)\n10. Add 'Net Worth' to sidebar navigation and app-shell PageId",
        "testStrategy": "Test database CRUD operations for net worth entries. Verify JSON storage and retrieval of custom labels. Test linear regression calculation for projection. Test delete confirmation dialog shows appropriate warning. Verify chart renders correctly with projection line.",
        "priority": "medium",
        "dependencies": [1],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Database Schema and Types",
            "description": "Add net_worth_entry table to database schema and create TypeScript types",
            "dependencies": [],
            "details": "Add net_worth_entry table to lib/db/schema.ts with columns: id, recorded_at, assets_data (JSON text), liabilities_data (JSON text), total_assets, total_liabilities, net_worth, notes, created_at. Create types/net-worth.ts with NetWorthEntry interface and asset/liability field structures.",
            "status": "done",
            "testStrategy": "Verify table creation works. Test TypeScript types compile correctly."
          },
          {
            "id": 2,
            "title": "Database Operations Layer",
            "description": "Create lib/db/net-worth.ts with CRUD operations",
            "dependencies": [1],
            "details": "Implement functions: createNetWorthEntry, getAllNetWorthEntries, getNetWorthEntryById, updateNetWorthEntry, deleteNetWorthEntry. Handle JSON serialization/deserialization for assets_data and liabilities_data fields.",
            "status": "done",
            "testStrategy": "Unit tests for all CRUD operations. Test JSON serialization works correctly."
          },
          {
            "id": 3,
            "title": "API Routes",
            "description": "Create API routes for net worth operations",
            "dependencies": [2],
            "details": "Create app/api/net-worth/route.ts with GET (list all) and POST (create). Create app/api/net-worth/[id]/route.ts with GET (single), PUT (update), DELETE. Add Zod validation for request bodies.",
            "status": "done",
            "testStrategy": "Test all API endpoints with valid and invalid payloads."
          },
          {
            "id": 4,
            "title": "Record Net Worth Dialog",
            "description": "Build dialog form for recording net worth snapshots with customizable labels",
            "dependencies": [3],
            "details": "Create components/net-worth/record-dialog.tsx with date picker, assets section (12 fields with editable labels), liabilities section (7 fields with editable labels). Each field has label input and value input. Calculate totals on save. Support both create and edit modes.",
            "status": "done",
            "testStrategy": "Test form validation. Test label customization persists. Test totals calculate correctly."
          },
          {
            "id": 5,
            "title": "Entries Table with Delete Warning",
            "description": "Build table component displaying net worth entries with edit and delete actions",
            "dependencies": [3],
            "details": "Create components/net-worth/entries-table.tsx with columns: Date, Total Assets, Total Liabilities, Net Worth, Actions. Edit button opens pre-filled dialog. Delete button shows confirmation dialog with prominent warning about permanent deletion.",
            "status": "done",
            "testStrategy": "Test table renders entries correctly. Test edit opens dialog with correct data. Test delete shows warning and requires confirmation."
          },
          {
            "id": 6,
            "title": "Net Worth Chart with Projection",
            "description": "Build line chart with historical data and 5-year dashed projection line",
            "dependencies": [3],
            "details": "Create components/net-worth/net-worth-chart.tsx using Recharts LineChart. Solid line for historical net worth values. Implement linear regression calculation. Add dashed line projecting 5 years into future (only when 2+ data points). Style to match existing dashboard charts.",
            "status": "done",
            "testStrategy": "Test chart renders with sample data. Test projection calculation is reasonable. Test styling matches app theme."
          },
          {
            "id": 7,
            "title": "Net Worth Page Component",
            "description": "Create main page combining chart, table, and record button",
            "dependencies": [4, 5, 6],
            "details": "Create components/pages/net-worth.tsx with header (title + 'Record Net Worth' button), NetWorthChart, and EntriesTable. Fetch data from API on mount. Handle loading and empty states.",
            "status": "done",
            "testStrategy": "Test page loads and displays all components. Test record button opens dialog. Test data refresh after create/edit/delete."
          },
          {
            "id": 8,
            "title": "Navigation Integration",
            "description": "Add Net Worth page to sidebar and app-shell routing",
            "dependencies": [7],
            "details": "Add 'net-worth' to PageId type in app-shell.tsx. Add nav item to sidebar.tsx with Wallet icon from lucide-react. Import and render NetWorthPage in app-shell switch statement.",
            "status": "done",
            "testStrategy": "Test navigation to Net Worth page works. Test sidebar highlights correctly when on page."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-12-16T10:23:48.489Z",
      "updated": "2025-12-23T00:00:00.000Z",
      "description": "Tasks for master context"
    }
  }
}